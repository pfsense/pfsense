<?php
/*
 * dyndns.class
 *
 * part of pfSense (https://www.pfsense.org)
 * Copyright (c) 2004-2013 BSD Perimeter
 * Copyright (c) 2013-2016 Electric Sheep Fencing
 * Copyright (c) 2014-2023 Rubicon Communications, LLC (Netgate)
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

	/*
	 * PHP.updateDNS (pfSense version)
	 *
	 * +====================================================+
	 *  Services Supported:
	 *    - All-Inkl (all-inkl.com)
	 *    - Amazon Route 53 (aws.amazon.com)
	 *    - Azure DNS (azure.microsoft.com)
	 *    - City Network (citynetwork.se)
	 *    - Cloudflare (www.cloudflare.com)
	 *    - Cloudflare IPv6 (www.cloudflare.com)
	 *    - ClouDNS (www.cloudns.net)
	 *    - Custom DDNS (any URL)
	 *    - Custom DDNS IPv6 (any URL)
	 *    - deSEC (desec.io)
	 *    - DHS (www.dhs.org)
	 *    - DNS Made Easy (www.dnsmadeeasy.com)
	 *    - DNS-O-Matic (dnsomatic.com)
	 *    - DNSexit (dnsexit.com)
	 *    - DNSimple (dnsimple.com)
	 *    - DreamHost DNS (www.dreamhost.com)
	 *    - DuiaDNS (www.duiadns.net)
	 *    - DuiaDNS IPv6 (www.duiadns.net)
	 *    - DY.fi (dy.fi)
	 *    - DynDns (dyndns.org) [dynamic, static, custom]
	 *    - DynS (dyns.org)
	 *    - Dynv6 (www.dynv6.com)
	 *    - EasyDNS (easydns.com)
	 *    - EasyDNS IPv6 (easydns.com)
	 *    - Eurodns (eurodns.com)
	 *    - FreeDNS API v1 (freedns.afraid.org)
	 *    - FreeDNS API v2 (freedns.afraid.org)
	 *    - FreeDNS IPv6 API v1 (freedns.afraid.org)
	 *    - FreeDNS IPv6 API v2 (freedns.afraid.org)
	 *    - Gandi LiveDNS (www.gandi.net)
	 *    - GleSYS (glesys.com)
	 *    - GoDaddy (www.godaddy.com)
	 *    - Google Domains (domains.google.com)
	 *    - GratisDNS (gratisdns.dk)
	 *    - HE.net (dns.he.net)
	 *    - HE.net IPv6 (dns.he.net)
	 *    - HE.net Tunnelbroker IP update (ipv4.tunnelbroker.net)
	 *    - HN (hn.org) -- incomplete checking!
	 *    - Hover (www.hover.com)
	 *    - Loopia (loopia.se)
	 *    - Name.com (name.com)
	 *    - Name.com IPv6 (name.com)
	 *    - Namecheap (namecheap.com)
	 *    - No-IP (no-ip.com)
	 *    - OpenDNS (opendns.com)
	 *    - SelfHost (selfhost.de)
	 *    - SPDYN (spdyn.de)
	 *    - SPDYN IPv6 (spdyn.de)
	 *    - StaticCling (staticcling.org)
	 *    - Strato (www.strato.de)
	 *    - ZoneEdit (zoneedit.com)
	 * +----------------------------------------------------+
	 *  Requirements:
	 *    - PHP version 4.0.2 or higher with the CURL Library and the PCRE Library
	 * +----------------------------------------------------+
	 *  Public Functions
	 *    - updatedns()
	 *
	 *  Private Functions
	 *    - _update()
	 *    - _checkStatus()
	 *    - _error()
	 *    - _detectChange()
	 *    - _debug()
	 *    - _checkIP()
	 * +----------------------------------------------------+
	 *  All-Inkl        - Last Tested: 12 November 2016
	 *  Amazon Route 53 - Last Tested: 04 February 2017
	 *  Azure DNS       - Last Tested: 08 March 2018
	 *  City Network    - Last Tested: 13 November 2013
	 *  Cloudflare      - Last Tested: 05 September 2016
	 *  Cloudflare IPv6 - Last Tested: 17 July 2016
	 *  ClouDNS         - Last Tested: 22 August 2017
	 *  deSEC           - Last Tested: NEVER
	 *  deSEC IPv6      - Last Tested: NEVER
	 *  DHS             - Last Tested: 12 July 2005
	 *  DigitalOcean    - Not Yet Tested
	 *  DNS Made Easy   - Last Tested: 27 April 2015
	 *  DNS-O-Matic     - Last Tested: 9 September 2010
	 *  DNSexit         - Last Tested: 27 June 2022
	 *  DNSimple        - Last Tested: 09 February 2015
	 *  DreamHost       - Last Tested: 30 April 2017
	 *  DreamHost IPv6  - Not Yet Tested
	 *  DuiaDNS         - Last Tested: 25 November 2016
	 *  DuiaDNS IPv6    - Last Tested: 25 November 2016
	 *  DY.fi           - Last Tested: 22 April 2021
	 *  DynDNS Custom   - Last Tested: NEVER
	 *  DynDNS Dynamic  - Last Tested: 12 July 2005
	 *  DynDNS Static   - Last Tested: NEVER
	 *  Dyns            - Last Tested: NEVER
	 *  EasyDNS         - Last Tested: 20 July 2008
	 *  Eurodns         - Last Tested: 27 June 2013
	 *  FreeDNS         - Last Tested: 01 May 2016
	 *  FreeDNS IPv6    - Last Tested: 01 May 2016
	 *  FreeDNS IPv6 v2 - Last Tested: 01 June 2020
	 *  FreeDNS v2      - Last Tested: 01 June 2020
	 *  Gandi LiveDNS   - Not Yet Tested
	 *  GleSYS          - Last Tested: 3 February 2015
	 *  GoDaddy         - Last Tested: 22 November 2017
	 *  GoDaddy IPv6    - Last Tested: 22 November 2017
	 *  Google Domains  - Last Tested: 27 April 2015
	 *  GratisDNS       - Last Tested: 15 August 2012
	 *  HE.net          - Last Tested: 7 July 2013
	 *  HE.net IPv6     - Last Tested: 7 July 2013
	 *  HE.net Tunnel   - Last Tested: 28 June 2011
	 *  HN.org          - Last Tested: 12 July 2005
	 *  Hover           - Last Tested: 15 February 2017
	 *  Loopia          - Last Tested: 21 August 2019
	 *  Name.com        - Last Tested: 5 Dec 2021
	 *  Name.com IPv6   - Last Tested: 5 Dec 2021
	 *  Namecheap       - Last Tested: 31 August 2010
	 *  No-IP           - Last Tested: 20 July 2008
	 *  ODS             - Last Tested: 02 August 2005
	 *  OpenDNS         - Last Tested: 4 August 2008
	 *  OVH DynHOST     - Last Tested: NEVER
	 *  SelfHost        - Last Tested: 26 December 2011
	 *  SPDYN           - Last Tested: 02 July 2016
	 *  SPDYN IPv6      - Last Tested: 02 July 2016
	 *  StaticCling     - Last Tested: 27 April 2006
	 *  Strato          - Last Tested: 29 May 2021
	 *  ZoneEdit        - Last Tested: NEVER
	 * +====================================================+
	 *
	 * @author 	E.Kristensen
	 * @link    	http://www.idylldesigns.com/projects/phpdns/
	 * @version 	0.8
	 * @updated	13 October 05 at 21:02:42 GMT
	 *
	 * DNSexit/OpenDNS support and multiwan extension for pfSense by Ermal LuÃ§i and Koen Zomers
	 * Custom DNS support by Matt Corallo
	 *
	 */

	class updatedns {
		var $_cacheFile;
		var $_cacheFile_v6;
		var $_debugFile;
		var $_UserAgent = 'phpDynDNS/0.7';
		var $_errorVerbosity = 0;
		var $_dnsService;
		var $_dnsUser;
		var $_dnsPass;
		var $_dnsHost;
		var $_dnsDomain;
		var $_FQDN;
		var $_dnsIP;
		var $_dnsWildcard;
		var $_dnsProxied;
		var $_dnsMX;
		var $_dnsBackMX;
		var $_dnsServer;
		var $_dnsPort;
		var $_dnsUpdateURL;
		var $_dnsZoneID;
		var $_dnsTTL;
		var $status;
		var $_debugID;
		var $_if;
		var $_dnsResultMatch;
		var $_dnsRequestIf;
		var $_dnsRequestIfIP;
		var $_dnsVerboseLog;
		var $_curlIpresolveV4;
		var $_curlSslVerifypeer;
		var $_dnsMaxCacheAgeDays;
		var $_dnsDummyUpdateDone;
		var $_forceUpdateNeeded;
		var $_useIPv6;
		var $_existingRecords;
		var $_curlProxy;

		/*
		 * Public Constructor Function (added 12 July 05) [beta]
		 *   - Gets the dice rolling for the update.
		 *   - $dnsResultMatch should only be used with $dnsService = 'custom'
		 *   -  $dnsResultMatch is parsed for '%IP%', which is the IP the provider was updated to,
		 *   -  it is otherwise expected to be exactly identical to what is returned by the Provider.
		 *   - $dnsUser, and $dnsPass indicate HTTP Auth for custom DNS, if they are needed in the URL (GET Variables), include them in $dnsUpdateURL.
		 *   - $For custom requests, $dnsUpdateURL is parsed for '%IP%', which is replaced with the new IP.
		 */
		function __construct($dnsService = '', $dnsHost = '', $dnsDomain = '', $dnsUser = '', $dnsPass = '',
					$dnsWildcard = 'OFF', $dnsProxied = false, $dnsMX = '', $dnsIf = '', $dnsBackMX = '',
					$dnsServer = '', $dnsPort = '', $dnsUpdateURL = '', $forceUpdate = false,
					$dnsZoneID ='', $dnsTTL='', $dnsResultMatch = '', $dnsRequestIf = '', $dnsMaxCacheAge = '',
					$dnsID = '', $dnsVerboseLog = false, $curlIpresolveV4 = false, $curlSslVerifypeer = true,
					$curlProxy = false) {

			global $config, $g, $dyndns_split_domain_types;
			if (in_array($dnsService, $dyndns_split_domain_types)) {
				$this->_FQDN = $dnsHost . "." . $dnsDomain;
			} else {
				$this->_FQDN = $dnsHost;
			}

			$this->_cacheFile = "{$g['conf_path']}/dyndns_{$dnsIf}{$dnsService}" . escapeshellarg($this->_FQDN) . "{$dnsID}.cache";
			$this->_cacheFile_v6 = "{$g['conf_path']}/dyndns_{$dnsIf}{$dnsService}" . escapeshellarg($this->_FQDN) . "{$dnsID}_v6.cache";
			$this->_debugFile = "{$g['varetc_path']}/dyndns_{$dnsIf}{$dnsService}" . escapeshellarg($this->_FQDN) . "{$dnsID}.debug";

			$this->_curlIpresolveV4 = $curlIpresolveV4;
			$this->_curlSslVerifypeer = $curlSslVerifypeer;
			$this->_curlProxy = $curlProxy;
			$this->_dnsVerboseLog = $dnsVerboseLog;
			if ($this->_dnsVerboseLog) {
				log_error(gettext("Dynamic DNS: updatedns() starting"));
			}

			$dyndnslck = lock("DDNS" . $dnsID, LOCK_EX);

			if (!$dnsService) $this->_error(2);
			switch ($dnsService) {
			case 'custom':
			case 'custom-v6':
				if (!$dnsUpdateURL) $this->_error(7);
				break;
			// providers in an alphabetical order (based on the first provider in a group of cases)
			case 'azure':
			case 'azurev6':
				if (!$dnsUser) $this->_error(3);
				if (!$dnsPass) $this->_error(4);
				if (!$dnsHost) $this->_error(5);
				if (!$dnsZoneID) $this->_error(8);
				if (!$dnsTTL) $this->_error(9);
				break;
			case 'cloudflare':
			case 'cloudflare-v6':
				if (!$dnsPass) $this->_error(4);
				if (!$dnsHost) $this->_error(5);
				if (!$dnsDomain) $this->_error(5);
				break;
			case 'cloudns':
			case 'godaddy':
			case 'godaddy-v6':
				if (!$dnsUser) $this->_error(3);
				if (!$dnsPass) $this->_error(4);
				if (!$dnsHost) $this->_error(5);
				if (!$dnsDomain) $this->_error(5);
				if (!$dnsTTL) $this->_error(9);
				break;
			case 'desec':
			case 'desec-v6':
				if (!$dnsPass) $this->_error(4);
				if (!$dnsHost) $this->_error(5);
				break;
			case 'digitalocean':
			case 'digitalocean-v6':
			case 'gandi-livedns':
			case 'gandi-livedns-v6':
			case 'linode':
			case 'linode-v6':
			case 'onecom':
			case 'onecom-v6':
			case 'yandex':
			case 'yandex-v6':
				if (!$dnsPass) $this->_error(4);
				if (!$dnsHost) $this->_error(5);
				if (!$dnsDomain) $this->_error(5);
				if (!$dnsTTL) $this->_error(9);
				break;
			case 'freedns':
			case 'freedns-v6':
			case 'freedns2':
			case 'freedns2-v6':
				if (!$dnsHost) $this->_error(5);
				break;
			case 'gratisdns':
			case 'hover':
			case 'name.com':
			case 'name.com-v6':
				if (!$dnsUser) $this->_error(3);
				if (!$dnsPass) $this->_error(4);
				if (!$dnsHost) $this->_error(5);
				if (!$dnsDomain) $this->_error(5);
				break;
			case 'namecheap':
				if (!$dnsPass) $this->_error(4);
				if (!$dnsHost) $this->_error(5);
				if (!$dnsDomain) $this->_error(5);
				break;
			case 'route53':
			case 'route53-v6':
				if (!$dnsZoneID) $this->_error(8);
				if (!$dnsTTL) $this->_error(9);
				break;
			default:
				if (!$dnsUser) $this->_error(3);
				if (!$dnsPass) $this->_error(4);
				if (!$dnsHost) $this->_error(5);
			}

			switch ($dnsService) {
				case 'azurev6':
				case 'cloudflare-v6':
				case 'custom-v6':
				case 'desec-v6':
				case 'digitalocean-v6':
				case 'dnsimple-v6':
				case 'domeneshop-v6':
				case 'dreamhost-v6':
				case 'duiadns-v6':
				case 'dynv6-v6':
				case 'easydns-v6':
				case 'freedns-v6':
				case 'freedns2-v6':
				case 'gandi-livedns-v6':
				case 'godaddy-v6':
				case 'he-net-v6':
				case 'linode-v6':
				case 'mythicbeasts-v6':
				case 'name.com-v6':
				case 'noip-free-v6':
				case 'noip-v6':
				case 'route53-v6':
				case 'spdyn-v6':
				case 'yandex-v6':
					$this->_useIPv6 = true;
					break;
				default:
					$this->_useIPv6 = false;
			}
			$this->_dnsService = strtolower($dnsService);
			$this->_dnsUser = $dnsUser;
			$this->_dnsPass = base64_decode($dnsPass);
			$this->_dnsHost = $dnsHost;
			$this->_dnsDomain = $dnsDomain;
			$this->_dnsServer = $dnsServer;
			$this->_dnsPort = $dnsPort;
			$this->_dnsWildcard = $dnsWildcard;
			$this->_dnsProxied = $dnsProxied;
			$this->_dnsMX = $dnsMX;
			$this->_dnsZoneID = $dnsZoneID;
			$this->_dnsTTL = $dnsTTL;
			$this->_if = get_failover_interface($dnsIf);
			$this->_checkIP();
			$this->_dnsUpdateURL = $dnsUpdateURL;
			$this->_dnsResultMatch = $dnsResultMatch;
			if (($this->_dnsService == 'custom') || ($this->_dnsService == 'custom-v6')) {
				$this->_dnsRequestIf = get_failover_interface($dnsRequestIf);
			} else {
				$this->_dnsRequestIf = $this->_if;
			}
			if (($dnsMaxCacheAge !== null) && ($dnsMaxCacheAge !== "")) {
				$this->_dnsMaxCacheAgeDays = (int)$dnsMaxCacheAge;
			} else {
				switch ($dnsService) {
					// exceptions to _dnsMaxCacheAgeDays in an alphabetical order
					case 'dyfi':
						$this->_dnsMaxCacheAgeDays = 6;
						break;
					default:
						$this->_dnsMaxCacheAgeDays = 25;
				}
			}
			if ($this->_dnsVerboseLog) {
				log_error(sprintf(gettext('Dynamic DNS (%1$s): running get_failover_interface for %2$s. found %3$s'), $this->_FQDN, $dnsRequestIf, $this->_dnsRequestIf));
			}
			$this->_dnsRequestIfIP = get_interface_ip($dnsRequestIf);
			$this->_dnsDummyUpdateDone = false;
			$this->_forceUpdateNeeded = $forceUpdate;

			// Ensure that we were able to lookup the IP
			if (!is_ipaddr($this->_dnsIP)) {
				log_error(sprintf(gettext('Dynamic DNS (%1$s) There was an error trying to determine the public IP for interface - %2$s (%3$s %4$s).'), $this->_FQDN, $dnsIf, $this->_if, $this->_dnsIP));
				unlock($dyndnslck);
				return;
			}

			$this->_debugID = rand(1000000, 9999999);

			if ($forceUpdate == false && $this->_detectChange() == false) {
				$this->_error(10);
			} else {
				switch ($this->_dnsService) {
					case 'all-inkl':
					case 'azure':
					case 'azurev6':
					case 'citynetwork':
					case 'cloudflare':
					case 'cloudflare-v6':
					case 'cloudns':
					case 'custom':
					case 'custom-v6':
					case 'desec':
					case 'desec-v6':
					case 'dhs':
					case 'digitalocean':
					case 'digitalocean-v6':
					case 'dnsexit':
					case 'dnsimple':
					case 'dnsimple-v6':
					case 'dnsmadeeasy':
					case 'dnsomatic':
					case 'domeneshop':
					case 'domeneshop-v6':
					case 'duiadns':
					case 'duiadns-v6':
					case 'dyfi':
					case 'dyndns':
					case 'dyndns-custom':
					case 'dyndns-static':
					case 'dyns':
					case 'dynv6':
					case 'dynv6-v6':
					case 'easydns':
					case 'easydns-v6':
					case 'eurodns':
					case 'freedns':
					case 'freedns-v6':
					case 'freedns2':
					case 'freedns2-v6':
					case 'gandi-livedns':
					case 'gandi-livedns-v6':
					case 'glesys':
					case 'godaddy':
					case 'godaddy-v6':
					case 'googledomains':
					case 'gratisdns':
					case 'he-net':
					case 'he-net-tunnelbroker':
					case 'he-net-v6':
					case 'hn':
					case 'hover':
					case 'linode':
					case 'linode-v6':
					case 'loopia':
					case 'mythicbeasts':
					case 'mythicbeasts-v6':
					case 'name.com':
					case 'name.com-v6':
					case 'namecheap':
					case 'nicru':
					case 'nicru-v6':
					case 'noip':
					case 'noip-free':
					case 'noip-free-v6':
					case 'noip-v6':
					case 'ods':
					case 'opendns':
					case 'ovh-dynhost':
					case 'route53':
					case 'route53-v6':
					case 'selfhost':
					case 'spdyn':
					case 'spdyn-v6':
					case 'staticcling':
					case 'strato':
					case 'onecom':
					case 'onecom-v6':
					case 'yandex':
					case 'yandex-v6':
					case 'zoneedit':
						$this->_update();
						if ($this->_dnsDummyUpdateDone == true) {
							// If a dummy update was needed, then sleep a while and do the update again to put the proper address back.
							// Some providers (e.g. No-IP free accounts) need to have at least 1 address change every month.
							// If the address has not changed recently, or the user did "Force Update", then the code does
							// a dummy address change for providers like this.
							sleep(10);
							$this->_update();
						}
						break;
					case 'dreamhost':
					case 'dreamhost-v6':
						$this->_lookup_current();
						if (isset($this->status)) {
							return;
						}
						foreach ($this->_existingRecords as $record) {
							$this->_remove($record['existing_val']);
							$this->_update();
						}
						break;
					default:
						$this->_error(6);
						break;
				}
			}

			unlock($dyndnslck);
		}

		/*
		 * Private Function (added 12 July 05) [beta]
		 *   Send Update To Selected Service.
		 */
		function _update() {

			if ($this->_dnsVerboseLog) {
				log_error(sprintf(gettext('Dynamic DNS %1$s (%2$s): _update() starting.'), $this->_dnsService, $this->_FQDN));
			}

			if (strstr($this->_dnsRequestIf, "_vip")) {
				$parentif = get_configured_vip_interface($this->_dnsRequestIf);
				$realparentif = convert_friendly_interface_to_real_interface_name($parentif);
			} else {
				$realparentif = $this->_dnsRequestIf;
			}

			$ch = curl_init();

			if ($this->_useIPv6 == false) {
				curl_setopt($ch, CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V4);
			}

			if ($this->_dnsService != 'ods') {
				curl_setopt($ch, CURLOPT_USERAGENT, $this->_UserAgent);
				curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
				curl_setopt($ch, CURLOPT_INTERFACE, 'if!' . $realparentif);
				curl_setopt($ch, CURLOPT_TIMEOUT, 120); // Completely empirical
			}

			switch ($this->_dnsService) {
				// The special custom provider
				case 'custom':
				case 'custom-v6':
					if (strstr($this->dnsUpdateURL, "%IP%")) {$needsIP = TRUE;} else {$needsIP = FALSE;}
					if ($this->_dnsUser != '') {
						if ($this->_curlIpresolveV4) {
							curl_setopt($ch, CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V4);
						}
						if ($this->_curlSslVerifypeer) {
							/* required for a local CA
							 * see https://redmine.pfsense.org/issues/12589 */
							curl_setopt($ch, CURLOPT_CAPATH, "/etc/ssl/certs/");
							curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, TRUE);
						} else {
							curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);
						}
						curl_setopt($ch, CURLOPT_USERPWD, "{$this->_dnsUser}:{$this->_dnsPass}");
					}
					$server = str_replace("%IP%", $this->_dnsIP, $this->_dnsUpdateURL);
					if ($this->_dnsVerboseLog) {
						log_error(sprintf(gettext("Sending request to: %s"), $server));
					}
					curl_setopt($ch, CURLOPT_URL, $server);
					break;
				// Providers in an alphabetical order. Add code for new providers below in a correct position.
				case 'dyfi':
					// see specification at https://www.dy.fi/page/specification
					$needsIP = FALSE;
					$server = 'https://www.dy.fi/nic/update';
					curl_setopt($ch, CURLOPT_USERPWD, "{$this->_dnsUser}:{$this->_dnsPass}");
					curl_setopt($ch, CURLOPT_URL, "{$server}?hostname={$this->_dnsHost}");
					break;
				case 'glesys':
					$needsIP = TRUE;
					$server = 'https://api.glesys.com/domain/updaterecord/format/json';
					curl_setopt($ch, CURLOPT_USERPWD, $this->_dnsUser . ':' . $this->_dnsPass);
					$post_data['recordid'] = $this->_FQDN;
					$post_data['data'] = $this->_dnsIP;
					curl_setopt($ch, CURLOPT_URL, $server);
					curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);
					break;
				//
				// Not yet ordered providers.
				// TODO: When editing a provider, move it above in a correct position.
				//
				case 'dyndns':
				case 'dyndns-static':
				case 'dyndns-custom':
					$needsIP = FALSE;
					if (isset($this->_dnsWildcard) && $this->_dnsWildcard != "OFF") {
						$this->_dnsWildcard = "ON";
					}
					curl_setopt($ch, CURLOPT_USERPWD, $this->_dnsUser . ':' . $this->_dnsPass);
					$server = "https://members.dyndns.org/nic/update";
					$port = "";
					if ($this->_dnsServer) {
						$server = $this->_dnsServer;
					}
					if ($this->_dnsPort) {
						$port = ":" . $this->_dnsPort;
					}
					curl_setopt($ch, CURLOPT_URL, $server . $port . '?system=dyndns&hostname=' . $this->_dnsHost . '&myip=' . $this->_dnsIP . '&wildcard=' . $this->_dnsWildcard . '&mx=' . $this->_dnsMX . '&backmx=NO');
					break;
				case 'dhs':
					// DHS is disabled in the GUI because the following doesn't work.
					$needsIP = TRUE;
					$post_data['hostscmd'] = 'edit';
					$post_data['hostscmdstage'] = '2';
					$post_data['type'] = '4';
					$post_data['updatetype'] = 'Online';
					$post_data['mx'] = $this->_dnsMX;
					$post_data['mx2'] = '';
					$post_data['txt'] = '';
					$post_data['offline_url'] = '';
					$post_data['cloak'] = 'Y';
					$post_data['cloak_title'] = '';
					$post_data['ip'] = $this->_dnsIP;
					$post_data['domain'] = 'dyn.dhs.org';
					$post_data['hostname'] = $this->_dnsHost;
					$post_data['submit'] = 'Update';
					$server = "https://members.dhs.org/nic/hosts";
					$port = "";
					if ($this->_dnsServer) {
						$server = $this->_dnsServer;
					}
					if ($this->_dnsPort) {
						$port = ":" . $this->_dnsPort;
					}
					curl_setopt($ch, CURLOPT_URL, $server . $port);
					curl_setopt($ch, CURLOPT_USERPWD, $this->_dnsUser . ':' . $this->_dnsPass);
					curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);
					break;
				case 'noip-v6':
				case 'noip-free-v6':
					$needsIP = TRUE;
					curl_setopt($ch, CURLOPT_USERPWD, $this->_dnsUser . ':' . $this->_dnsPass);
					$server = "https://dynupdate.no-ip.com/nic/update";
					$port = "";
					if ($this->_dnsServer) {
						$server = $this->_dnsServer;
					}
					if ($this->_dnsPort) {
						$port = ":" . $this->_dnsPort;
					}
					if (($this->_dnsService == "noip-free-v6") &&
					    ($this->_forceUpdateNeeded == true) &&
					    ($this->_dnsDummyUpdateDone == false)) {
						// Update the IP to a dummy value to force No-IP free accounts to see a change.
						$iptoset = "fd00:d::1";
						$this->_dnsDummyUpdateDone = true;
						$log_message = 'Dynamic DNS %1$s (%2$s): ';
						$log_message .= 'Processing dummy update on No-IP free account. ';
						$log_message .= 'IP temporarily set to %3$s';
						log_error(sprintf(gettext($log_message), $this->_dnsService, $this->_dnsHost, $iptoset));
					} else {
						$iptoset = $this->_dnsIP;
					}
					curl_setopt($ch, CURLOPT_URL, $url_data);
					curl_setopt($ch, CURLOPT_URL, $server . $port . '?hostname=' . $this->_dnsHost . '&myipv6=' . $iptoset);
					break;
				case 'noip':
				case 'noip-free':
					$needsIP = TRUE;
					curl_setopt($ch, CURLOPT_USERPWD, $this->_dnsUser . ':' . $this->_dnsPass);
					$server = "https://dynupdate.no-ip.com/nic/update";
					$port = "";
					if ($this->_dnsServer) {
						$server = $this->_dnsServer;
					}
					if ($this->_dnsPort) {
						$port = ":" . $this->_dnsPort;
					}
					if (($this->_dnsService == "noip-free") &&
					    ($this->_forceUpdateNeeded == true) &&
					    ($this->_dnsDummyUpdateDone == false)) {
						// Update the IP to a dummy value to force No-IP free accounts to see a change.
						$iptoset = "192.168.1.1";
						$this->_dnsDummyUpdateDone = true;
						log_error(sprintf(gettext('Dynamic DNS %1$s (%2$s): Processing dummy update on No-IP free account. IP temporarily set to %3$s'), $this->_dnsService, $this->_dnsHost, $iptoset));
					} else {
						$iptoset = $this->_dnsIP;
					}
					curl_setopt($ch, CURLOPT_URL, $server . $port . '?hostname=' . $this->_dnsHost . '&myip=' . $iptoset);
					break;
				case 'easydns':
					$needsIP = TRUE;
					curl_setopt($ch, CURLOPT_USERPWD, $this->_dnsUser . ':' . $this->_dnsPass);
					$server = "https://members.easydns.com/dyn/dyndns.php";
					$port = "";
					if ($this->_dnsServer) {
						$server = $this->_dnsServer;
					}
					if ($this->_dnsPort) {
						$port = ":" . $this->_dnsPort;
					}
					curl_setopt($ch, CURLOPT_URL, $server . $port . '?hostname=' . $this->_dnsHost . '&myip=' . $this->_dnsIP . '&wildcard=' . $this->_dnsWildcard . '&mx=' . $this->_dnsMX . '&backmx=' . $this->_dnsBackMX);
					break;
				case 'easydns-v6':
					$needsIP = TRUE;
					curl_setopt($ch, CURLOPT_USERPWD, $this->_dnsUser . ':' . $this->_dnsPass);
					$server = "https://members.easydns.com/dyn/dyndns.php";
					$port = "";
					if ($this->_dnsServer) {
						$server = $this->_dnsServer;
					}
					if ($this->_dnsPort) {
						$port = ":" . $this->_dnsPort;
					}
					curl_setopt($ch, CURLOPT_URL, $server . $port . '?hostname=' . $this->_dnsHost . '&myip=' . $this->_dnsIP . '&wildcard=' . $this->_dnsWildcard . '&mx=' . $this->_dnsMX . '&backmx=' . $this->_dnsBackMX);
					break;
				case 'hn':
					$needsIP = TRUE;
					curl_setopt($ch, CURLOPT_USERPWD, $this->_dnsUser . ':' . $this->_dnsPass);
					$server = "http://dup.hn.org/vanity/update";
					$port = "";
					if ($this->_dnsServer) {
						$server = $this->_dnsServer;
					}
					if ($this->_dnsPort) {
						$port = ":" . $this->_dnsPort;
					}
					curl_setopt($ch, CURLOPT_URL, $server . $port . '?ver=1&IP=' . $this->_dnsIP);
					break;
				case 'zoneedit':
					$needsIP = FALSE;
					curl_setopt($ch, CURLOPT_USERPWD, $this->_dnsUser . ':' . $this->_dnsPass);

					$server = "https://dynamic.zoneedit.com/auth/dynamic.html";
					$port = "";
					if ($this->_dnsServer) {
						$server = $this->_dnsServer;
					}
					if ($this->_dnsPort) {
						$port = ":" . $this->_dnsPort;
					}
					curl_setopt($ch, CURLOPT_URL, "{$server}{$port}?host=" . $this->_dnsHost . '&dnsto=' . $this->_dnsIP);
					break;
				case 'dyns':
					$needsIP = FALSE;
					$server = "http://www.dyns.net/postscript011.php";
					$port = "";
					if ($this->_dnsServer) {
						$server = $this->_dnsServer;
					}
					if ($this->_dnsPort) {
						$port = ":" . $this->_dnsPort;
					}
					curl_setopt($ch, CURLOPT_URL, $server . $port . '?username=' . urlencode($this->_dnsUser) . '&password=' . $this->_dnsPass . '&host=' . $this->_dnsHost);
					break;
				case 'ods':
					$needsIP = FALSE;
					$misc_errno = 0;
					$misc_error = "";
					$server = "ods.org";
					$port = "";
					if ($this->_dnsServer) {
						$server = $this->_dnsServer;
					}
					if ($this->_dnsPort) {
						$port = ":" . $this->_dnsPort;
					}
					$this->con['socket'] = fsockopen("{$server}{$port}", "7070", $misc_errno, $misc_error, 30);
					/* Check that we have connected */
					if (!$this->con['socket']) {
						print "error! could not connect.";
						break;
					}
					/* Here is the loop. Read the incoming data (from the socket connection) */
					while (!feof($this->con['socket'])) {
						$this->con['buffer']['all'] = trim(fgets($this->con['socket'], 4096));
						$code = substr($this->con['buffer']['all'], 0, 3);
						sleep(1);
						switch ($code) {
							case 100:
								fputs($this->con['socket'], "LOGIN " . $this->_dnsUser . " " . $this->_dnsPass . "\n");
								break;
							case 225:
								fputs($this->con['socket'], "DELRR " . $this->_dnsHost . " A\n");
								break;
							case 901:
								fputs($this->con['socket'], "ADDRR " . $this->_dnsHost . " A " . $this->_dnsIP . "\n");
								break;
							case 795:
								fputs($this->con['socket'], "QUIT\n");
								break;
						}
					}
					$this->_checkStatus(null, null, $code, null);
					break;
				case 'freedns':
				case 'freedns-v6':
					$needIP = TRUE;
					curl_setopt($ch, CURLOPT_URL, 'https://freedns.afraid.org/dynamic/update.php?' . $this->_dnsPass . '&address=' . $this->_dnsIP);
					break;
				case 'freedns2':
					$needIP = TRUE;
					curl_setopt($ch, CURLOPT_URL, 'https://sync.afraid.org/u/' . $this->_dnsPass . '/?hostname=' . $this->_dnsHost . '&myip=' . $this->_dnsIP);
					break;
				case 'freedns2-v6':
					$needIP = TRUE;
					curl_setopt($ch, CURLOPT_URL, 'https://v6.sync.afraid.org/u/' . $this->_dnsPass . '/?hostname=' . $this->_dnsHost . '&myip=' . $this->_dnsIP);
					break;
				case 'dnsexit':
					$needsIP = TRUE;
					curl_setopt($ch, CURLOPT_URL, 'https://api.dnsexit.com/dns/ud/?apikey=' . $this->_dnsPass . '&host=' . $this->_dnsHost . '&ip=' . $this->_dnsIP);
					break;
				case 'loopia':
					$needsIP = TRUE;
					if(isset($this->_dnsWildcard) && $this->_dnsWildcard == TRUE) {
						$this->_dnsWildcard = "ON";
					} else {
						$this->_dnsWildcard = "OFF";
					}
					curl_setopt($ch, CURLOPT_USERPWD, "{$this->_dnsUser}:{$this->_dnsPass}");
					curl_setopt($ch, CURLOPT_URL, "https://dyndns.loopia.se/?system=custom&hostname={$this->_dnsHost}&myip={$this->_dnsIP}&wildcard={$this->_dnsWildcard}&mx={$this->_dnsMX}&backmx=NO");
					break;
				case 'opendns':
					$needsIP = FALSE;
					if (isset($this->_dnsWildcard) && $this->_dnsWildcard != "OFF") $this->_dnsWildcard = "ON";
					curl_setopt($ch, CURLOPT_USERPWD, $this->_dnsUser . ':' . $this->_dnsPass);
					$server = "https://updates.opendns.com/nic/update?hostname=" . $this->_dnsHost;
					$port = "";
					if ($this->_dnsServer) {
						$server = $this->_dnsServer;
					}
					if ($this->_dnsPort) {
						$port = ":" . $this->_dnsPort;
					}
					curl_setopt($ch, CURLOPT_URL, $server . $port);
					break;

				case 'staticcling':
					$needsIP = FALSE;
					curl_setopt($ch, CURLOPT_URL, 'https://www.staticcling.org/update.html?login=' . $this->_dnsUser . '&pass=' . $this->_dnsPass);
					break;
				case 'dnsomatic':
					/* Example syntax
						https://username:password@updates.dnsomatic.com/nic/update?hostname=yourhostname&myip=ipaddress&wildcard=NOCHG&mx=NOCHG&backmx=NOCHG
					*/
					$needsIP = FALSE;
					if (isset($this->_dnsWildcard) && $this->_dnsWildcard != "OFF") {
						$this->_dnsWildcard = "ON";
					}
					/*
					Reference: https://www.dnsomatic.com/docs/api
						DNS-O-Matic usernames are 3-25 characters.
						DNS-O-Matic passwords are 6-20 characters.
						All ASCII letters and numbers accepted.
						Dots, dashes, and underscores allowed, but not at the beginning or end of the string.
					Required: "rawurlencode" https://www.php.net/manual/en/function.rawurlencode.php
						Encodes the given string according to RFC 3986.
					*/
					$server = "https://" . rawurlencode($this->_dnsUser) . ":" . rawurlencode($this->_dnsPass) . "@updates.dnsomatic.com/nic/update?hostname=";
					if ($this->_dnsServer) {
						$server = $this->_dnsServer;
					}
					if ($this->_dnsPort) {
						$port = ":" . $this->_dnsPort;
					}
					curl_setopt($ch, CURLOPT_URL, $server . $this->_dnsHost . '&myip=' . $this->_dnsIP . '&wildcard=' . $this->_dnsWildcard . '&mx=' . $this->_dnsMX . '&backmx=NOCHG');
					break;
				case 'domeneshop':
				case 'domeneshop-v6':
					/* Example:
						https://{token}:{secret}@api.domeneshop.no/v0/dyndns/update?hostname=example.com&myip=127.0.0.1
					*/
					$needsIP = FALSE;
					$server = "https://{$this->_dnsUser}:{$this->_dnsPass}@api.domeneshop.no/v0/dyndns/update?hostname={$this->_dnsHost}&myip={$this->_dnsIP}";
					curl_setopt($ch, CURLOPT_URL, $server);
					break;
				case 'mythicbeasts':
				case 'mythicbeasts-v6':
					/* Example:
						https://{login}:{password}@https://api.mythic-beasts.com/dns/v2/zones/example.com/records/test1/A -d data=1.2.3.4
					*/
					$needsIP = FALSE;
					if ($this->_useIPv6) {
						$record = "AAAA";
					} else {
						$record = "A";
					}
					$post_data['data'] = $this->_dnsIP;
					$server = "https://api.mythic-beasts.com/dns/v2/zones/{$this->_dnsDomain}/records/{$this->_dnsHost}/{$record}";
					curl_setopt($ch, CURLOPT_USERPWD, $this->_dnsUser . ':' . $this->_dnsPass);
					curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);
					curl_setopt($ch, CURLOPT_URL, $server);
					break;
				case 'name.com':
				case 'name.com-v6':
					// API documentation: https://www.name.com/api-docs/ & https://www.name.com/api-docs/dns
					$namedotcom_api = "https://api.name.com/v4/domains/{$this->_dnsDomain}/records";
					curl_setopt($ch, CURLOPT_USERPWD, $this->_dnsUser . ':' . $this->_dnsPass);
					$record_type = $this->_useIPv6 ? "AAAA" : "A";
					// Check if a record already exists for this host.
					curl_setopt($ch, CURLOPT_URL, "{$namedotcom_api}?perPage=1000");
					curl_setopt($ch, CURLOPT_FORBID_REUSE, true);
					$response = json_decode(curl_exec($ch), true);
					$http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);
					if ($http_code != "200") {
						log_error(gettext("Error message: ") . $response);
						return false;
					}
					if (!is_array($response["records"])) {
						log_error(gettext("Unexpected response: ") . $response);
						return false;
					}
					foreach($response["records"] as $record) {
						if (($record["domainName"] == $this->_dnsDomain) &&
							($record["host"] == $this->_dnsHost) &&
							($record["type"] == $record_type)) {
								$record_id = $record["id"];
								$existing_ttl = $record["ttl"];
								break;
						}
					}
					if (!$record_id && $response["nextPage"])
					{
						log_error(gettext("Too many (>1000) Name.com DNS records. Paging not supported."));
						return false;
					}
					// Either update an existing record or create a new one.
					$post_data['host'] = $this->_dnsHost;
					$post_data['type'] = $record_type;
					$post_data['answer'] = $this->_dnsIP;
					$post_data['ttl'] = max($this->_dnsTTL ?: $existing_ttl, 300);
					curl_setopt($ch, CURLOPT_URL, "{$namedotcom_api}/{$record_id}");
					curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($post_data));
					curl_setopt($ch, CURLOPT_HTTPHEADER, array('Content-Type: application/json'));
					curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $record_id ? "PUT" : "POST");
					break;
				case 'namecheap':
					/* Example:
						https://dynamicdns.park-your-domain.com/update?host=[host_name]&domain=[domain.com]&password=[domain_password]&ip=[your_ip]
					*/
					$needsIP = FALSE;
					$dnspass = trim($this->_dnsPass);
					$server = "https://dynamicdns.park-your-domain.com/update?host={$this->_dnsHost}&domain={$this->_dnsDomain}&password={$dnspass}&ip={$this->_dnsIP}";
					curl_setopt($ch, CURLOPT_URL, $server);
					break;
				case 'nicru':
				case 'nicru-v6':
					/* see https://www.nic.ru/help/dynamic-dns-for-developers_5810.html */
					$needsIP = FALSE;
					if (is_ipaddrv6($this->_dnsIP)) {
						$iptype = "ipv6";
					} else {
						$iptype = "myip";
					}
					curl_setopt($ch, CURLOPT_USERPWD, $this->_dnsUser . ':' . $this->_dnsPass);
					$server = "https://api.nic.ru/dyndns/update?hostname={$this->_dnsHost}&{$iptype}={$this->_dnsIP}";
					curl_setopt($ch, CURLOPT_URL, $server);
					break;
				case 'yandex':
				case 'yandex-v6':
					// https://yandex.com/dev/connect/directory/api/concepts/domains/dns-records-via-pdd.html

					if (is_ipaddrv4($this->_dnsIP)) {
						$type = 'A';
					} else {
						$type = 'AAAA';
					}

					// get record_id
					curl_setopt($ch, CURLOPT_URL, "https://pddimp.yandex.ru/api2/admin/dns/list?domain={$this->_dnsDomain}");
					curl_setopt($ch, CURLOPT_HTTPHEADER, array('PddToken: ' . $this->_dnsPass));
					curl_setopt($ch, CURLOPT_FORBID_REUSE, true);
					$output = json_decode(curl_exec($ch), true);
					if (is_array($output["records"])) {
						foreach($output["records"] as $record) {
							if (($record["domain"] == $this->_dnsDomain) &&
							    ($record["subdomain"] == $this->_dnsHost) &&
							    ($record["type"] == $type)) {
								$record_id = $record["record_id"];
							}
						}
					}

					if ($record_id) {
						$action = 'edit';
						$post_data['record_id'] = $record_id;
					} else {
						$action = 'add';
					}

					$post_data['domain'] = $this->_dnsDomain;
					$post_data['subdomain'] = $this->_dnsHost;
					$post_data['content'] = $this->_dnsIP;
					$post_data['type'] = $type;
					if ($this->_dnsTTL) {
						$post_data['ttl'] = $this->_dnsTTL;
					}

					curl_setopt($ch, CURLOPT_URL, 'https://pddimp.yandex.ru/api2/admin/dns/' . $action);
					curl_setopt($ch, CURLOPT_HTTPHEADER, array('PddToken: ' . $this->_dnsPass));
					curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);
					break;
				case 'duiadns':
				case 'duiadns-v6':
					$needsIP = FALSE;
					$server = "https://ipv4.duiadns.net/dyndns.duia?";
					curl_setopt($ch, CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V4);
					curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);
					curl_setopt($ch, CURLOPT_USERPWD, $this->_dnsUser . ':' . $this->_dnsPass);
					curl_setopt($ch, CURLOPT_URL, $server . 'hostname=' . $this->_dnsHost . '&myip=' . $this->_dnsIP);
					break;
				case 'he-net':
				case 'he-net-v6':
					$needsIP = FALSE;
					$server = "https://dyn.dns.he.net/nic/update?";
					curl_setopt($ch, CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V4);
					curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);
					curl_setopt($ch, CURLOPT_URL, $server . 'hostname=' . $this->_dnsHost . '&password=' . $this->_dnsPass . '&myip=' . $this->_dnsIP);
					break;
				case 'he-net-tunnelbroker':
					$needsIP = FALSE;
					$server = "https://ipv4.tunnelbroker.net/nic/update?";
					curl_setopt($ch, CURLOPT_USERPWD, $this->_dnsUser . ':' . $this->_dnsPass);
					curl_setopt($ch, CURLOPT_URL, $server . 'hostname=' . $this->_dnsHost . '&myip=' . $this->_dnsIP);
					break;
				case 'selfhost':
					$needsIP = FALSE;
					if (isset($this->_dnsWildcard) && $this->_dnsWildcard != "OFF") {
						$this->_dnsWildcard = "ON";
					}
					curl_setopt($ch, CURLOPT_USERPWD, $this->_dnsUser . ':' . $this->_dnsPass);
					$server = "https://carol.selfhost.de/nic/update";
					$port = "";
					if ($this->_dnsServer) {
						$server = $this->_dnsServer;
					}
					if ($this->_dnsPort) {
						$port = ":" . $this->_dnsPort;
					}
					curl_setopt($ch, CURLOPT_URL, $server . $port . '?system=dyndns&hostname=' . $this->_dnsHost . '&myip=' . $this->_dnsIP . '&wildcard=' . $this->_dnsWildcard . '&mx=' . $this->_dnsMX . '&backmx=NO');
					break;
				case 'strato':
					$needsIP = FALSE;
					$server = 'https://dyndns.strato.com/nic/update';
					curl_setopt($ch, CURLOPT_USERPWD, $this->_dnsUser . ':' . $this->_dnsPass);
					curl_setopt($ch, CURLOPT_URL, $server . '?hostname=' . $this->_dnsHost . '&myip=' . $this->_dnsIP);
					break;
				case 'route53':
					require_once("r53.class");
					$r53 = new Route53($this->_dnsUser, $this->_dnsPass);
					$apiurl = $r53->getApiUrl($this->_dnsZoneID);
					$xmlreq = $r53->getRequestBody($this->_dnsHost, $this->_dnsIP, $this->_dnsTTL);
					$httphead = $r53->getHttpPostHeaders($this->_dnsZoneID, "us-east-1", hash("sha256",$xmlreq));
					curl_setopt($ch, CURLOPT_HTTPHEADER, $httphead);
					if($this->_dnsVerboseLog){
						log_error(sprintf("Sending request to: %s", $apiurl));
						foreach($httphead as $hv){
							log_error(sprintf("Header: %s", $hv));
						}
						log_error(sprintf("XMLPOST: %s", $xmlreq));
					}
					curl_setopt($ch, CURLOPT_URL, $apiurl);
					curl_setopt($ch, CURLOPT_POSTFIELDS, $xmlreq);
					break;
				case 'route53-v6':
					require_once("r53.class");
					$r53 = new Route53($this->_dnsUser, $this->_dnsPass);
					$apiurl = $r53->getApiUrl($this->_dnsZoneID);
					$xmlreq = $r53->getRequestBodyV6($this->_dnsHost, $this->_dnsIP, $this->_dnsTTL);
					$httphead = $r53->getHttpPostHeaders($this->_dnsZoneID, "us-east-1", hash("sha256",$xmlreq));
					curl_setopt($ch, CURLOPT_HTTPHEADER, $httphead);
					if($this->_dnsVerboseLog){
						log_error(sprintf("Sending request to: %s", $apiurl));
						foreach($httphead as $hv){
							log_error(sprintf("Header: %s", $hv));
						}
						log_error(sprintf("XMLPOST: %s", $xmlreq));
					}
					curl_setopt($ch, CURLOPT_URL, $apiurl);
					curl_setopt($ch, CURLOPT_POSTFIELDS, $xmlreq);
					break;
				case 'cloudflare-v6':
				case 'cloudflare':
					$this->_FQDN = ltrim($this->_FQDN, '@.');
					$isv6 = ($this->_dnsService === 'cloudflare-v6');
					$recordType = $isv6 ? "AAAA" : "A";
					$needsIP = TRUE;
					$dnsServer ='api.cloudflare.com';
					$dnsHost = str_replace(' ', '', $this->_dnsHost);

					curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);

					if ((!$this->_dnsUser) || (strpos($this->_dnsUser, '@') !== false)) {
						if (strpos($this->_dnsUser, '@') !== false) {
							curl_setopt($ch, CURLOPT_HTTPHEADER, array(
										'X-Auth-Email: ' . $this->_dnsUser,
										'X-Auth-Key: ' . $this->_dnsPass,
										'Content-Type: application/json'
										));
						} else {
							curl_setopt($ch, CURLOPT_HTTPHEADER, array(
										'Authorization: Bearer ' . $this->_dnsPass,
										'Content-Type: application/json'
										));
						}

						// Get zone ID
						$getZoneId = "https://{$dnsServer}/client/v4/zones/?name={$this->_dnsDomain}";
						curl_setopt($ch, CURLOPT_URL, $getZoneId);
						curl_setopt($ch, CURLOPT_FORBID_REUSE, true);
						$output = json_decode(curl_exec($ch));
						$zone = $output->result[0]->id;
					} else {
						curl_setopt($ch, CURLOPT_HTTPHEADER, array(
							'Authorization: Bearer ' . $this->_dnsPass,
							'Content-Type: application/json'
						));

						$zone = $this->_dnsUser;
					}

					if ($zone) { // If zone ID was found get host ID
						$getHostId = "https://{$dnsServer}/client/v4/zones/{$zone}/dns_records?name={$this->_FQDN}&type={$recordType}";
						curl_setopt($ch, CURLOPT_URL, $getHostId);
						curl_setopt($ch, CURLOPT_FORBID_REUSE, true);
						$output = json_decode(curl_exec($ch));
						$host = $output->result[0]->id;
						if ($host) { // If host ID was found update host
							$hostData = array(
								"content" => "{$this->_dnsIP}",
								"type" => "{$recordType}",
								"proxied" => $this->_dnsProxied,
								"name" => "{$this->_dnsHost}",
								"ttl" => empty($this->_dnsTTL) ? 1 : (int) $this->_dnsTTL
							);
							$data_json = json_encode($hostData);
							$updateHostId = "https://{$dnsServer}/client/v4/zones/{$zone}/dns_records/{$host}";
							curl_setopt($ch, CURLOPT_URL, $updateHostId);
							curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'PUT');
							curl_setopt($ch, CURLOPT_POSTFIELDS, $data_json);
						}
					}
					break;
				case 'eurodns':
					$needsIP = TRUE;
					curl_setopt($ch, CURLOPT_USERPWD, $this->_dnsUser . ':' . $this->_dnsPass);
					$server = "https://update.eurodyndns.org/update/";
					$port = "";
					if ($this->_dnsPort) {
						$port = ":" . $this->_dnsPort;
					}
					curl_setopt($ch, CURLOPT_URL, $server . $port . '?hostname=' . $this->_dnsHost . '&myip=' . $this->_dnsIP);
					break;
				case 'gratisdns':
					$needsIP = TRUE;
					$server = "https://ssl.gratisdns.dk/ddns.phtml";
					curl_setopt($ch, CURLOPT_URL, $server . '?u=' . $this->_dnsUser . '&p=' . $this->_dnsPass . '&h=' . $this->_dnsHost . '&d=' . $this->_dnsDomain . '&i=' . $this->_dnsIP);
					break;
				case 'ovh-dynhost':
					$needsIP = FALSE;
					if (isset($this->_dnsWildcard) && $this->_dnsWildcard != "OFF") $this->_dnsWildcard = "ON";
					curl_setopt($ch, CURLOPT_USERPWD, $this->_dnsUser . ':' . $this->_dnsPass);
					$server = "https://www.ovh.com/nic/update";
					$port = "";
					if ($this->_dnsServer) {
						$server = $this->_dnsServer;
					}
					if ($this->_dnsPort) {
						$port = ":" . $this->_dnsPort;
					}
					curl_setopt($ch, CURLOPT_URL, $server . $port . '?system=dyndns&hostname=' . $this->_dnsHost . '&myip=' . $this->_dnsIP . '&wildcard=' . $this->_dnsWildcard . '&mx=' . $this->_dnsMX . '&backmx=NO');
					break;
				case 'citynetwork':
					$needsIP = TRUE;
					curl_setopt($ch, CURLOPT_USERPWD, $this->_dnsUser . ':' . $this->_dnsPass);
					$server = 'https://dyndns.citynetwork.se/nic/update';
					$port = "";
					if ($this->_dnsServer) {
						$server = $this->_dnsServer;
					}
					if ($this->_dnsPort) {
						$port = ":" . $this->_dnsPort;
					}
					curl_setopt($ch, CURLOPT_URL, $server . $port . '?hostname=' . $this->_dnsHost . '&myip=' . $this->_dnsIP);
					break;
				case 'dnsimple':
				case 'dnsimple-v6':
					/* Uses DNSimple's v2 REST API
					   Requires the Account ID as the username (found in the URL when pull up the domain)
					   And an API Token for the password (generated in the User Settings -> API tokens area of the website)
					   Piggybacks on Route 53's ZoneID field for the DNSimple record ID to update
					   The DNS record MUST exist before it can update since it performs a PATCH operation
					   Data sent as JSON over HTTPS */
					$needsIP = TRUE;
					$server = 'https://api.dnsimple.com/v2/';
					curl_setopt($ch, CURLOPT_CUSTOMREQUEST, "PATCH");
					curl_setopt($ch, CURLOPT_HTTPHEADER, array('Accept: application/json', 'Content-Type: application/json', 'Authorization: Bearer ' . $this->_dnsPass));
					curl_setopt($ch, CURLOPT_URL, $server . $this->_dnsUser . '/zones/' . $this->_dnsHost . '/records/' . $this->_dnsZoneID);
					curl_setopt($ch, CURLOPT_POSTFIELDS, '{"content":"' . $this->_dnsIP . '","ttl":"' . $this->_dnsTTL . '"}');
					break;
				case 'godaddy':
				case 'godaddy-v6':
					/* Uses GoDaddy's REST API
					   Requires username and Account API sso-key passed in header
					   Data sent as JSON */
					$needsIP = TRUE;
					$server = 'https://api.godaddy.com/v1/domains/';
					$recordType = $this->_useIPv6 ? "AAAA" : "A";
					$url = $server . $this->_dnsDomain . '/records/' . $recordType . '/' . $this->_dnsHost;
					$jsondata = '[{"data":"' . $this->_dnsIP . '","ttl":' . $this->_dnsTTL . '}]';
					curl_setopt($ch, CURLOPT_CUSTOMREQUEST, "PUT");
					curl_setopt($ch, CURLOPT_HTTPHEADER, array(
						'Accept: application/json',
						'Content-Type: application/json',
						'Authorization: sso-key ' . $this->_dnsUser . ':' . $this->_dnsPass
					));
					curl_setopt($ch, CURLOPT_URL, $url);
					curl_setopt($ch, CURLOPT_POSTFIELDS, $jsondata);
					break;
				case 'googledomains':
					$needsIP = FALSE;
					$post_data['username:password'] = $this->_dnsUser . ':' . $this->_dnsPass;
					$post_data['hostname'] = $this->_dnsHost;
					$post_data['myip'] = $this->_dnsIP;
					$post_data['offline'] = 'no';
					$server = "https://domains.google.com/nic/update";
					$port = "";
					curl_setopt($ch, CURLOPT_URL, 'https://domains.google.com/nic/update');
					curl_setopt($ch, CURLOPT_USERPWD, $this->_dnsUser . ':' . $this->_dnsPass);
					curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($post_data));
					curl_setopt($ch, CURLOPT_USERAGENT, $this->_UserAgent);
					curl_setopt($ch, CURLOPT_POST, 1);
					break;
				case 'dnsmadeeasy':
					$needsIP = TRUE;
					$server = "https://cp.dnsmadeeasy.com/servlet/updateip";
					$username = empty($this->_dnsUser) ? "" : "&username={$this->dnsUser}";
					curl_setopt($ch, CURLOPT_URL, $server . '?password=' . $this->_dnsPass . '&id=' . $this->_dnsHost . '&ip=' . $this->_dnsIP . $username);
					break;
				case 'spdyn':
				case 'spdyn-v6':
					$needsIP = FALSE;
					curl_setopt($ch, CURLOPT_USERPWD, $this->_dnsUser . ':' . $this->_dnsPass);
					$server = "https://update.spdyn.de/nic/update";
					$port = "";
					if ($this->_dnsServer) {
						$server = $this->_dnsServer;
					}
					if ($this->_dnsPort) {
						$port = ":" . $this->_dnsPort;
					}
					curl_setopt($ch, CURLOPT_URL, $server . $port . '?hostname=' . $this->_dnsHost . '&myip=' . $this->_dnsIP);
					break;
				case 'all-inkl':
					$needsIP = FALSE;
					$server = 'https://dyndns.kasserver.com/';
					curl_setopt($ch, CURLOPT_USERPWD, $this->_dnsUser . ':' . $this->_dnsPass);
					curl_setopt($ch, CURLOPT_URL, $server . 'myip=' . $this->_dnsIP);
					break;
				case 'hover':
					$needsIP = FALSE;
					$port = "";
					curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
					curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 1);

					//step 1: login to API
					$post_data['username'] = $this->_dnsUser;
					$post_data['password'] = $this->_dnsPass;
					curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);
					curl_setopt($ch, CURLOPT_URL, "https://www.hover.com/api/login");
					curl_setopt($ch, CURLOPT_HEADER, 1); //return the full headers to extract the cookies
					curl_setopt($ch, CURLOPT_FORBID_REUSE, true);
					$output = curl_exec($ch);

					//extract the cookies
					preg_match_all("/^Set-cookie: (.*?);/ism", $output, $cookies);
					if( count($cookies[1]) > 0 ){
						$cookie_data = implode("; ",$cookies[1]);
					}

					//step 2: find the id of the A record
					$post_data = null;
					curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);
					curl_setopt($ch, CURLOPT_COOKIE, $cookie_data);
					curl_setopt($ch, CURLOPT_HEADER, 0);
					curl_setopt($ch, CURLOPT_URL, "https://www.hover.com/api/dns");
					curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'GET');
					curl_setopt($ch, CURLOPT_FORBID_REUSE, true);
					$output = curl_exec($ch);
					$pregHost = preg_quote($this->_dnsHost);
					$pregDomain = preg_quote($this->_dnsDomain);
					preg_match("/^{\"succeeded\":true.*?domain_name\":\"{$pregDomain}.*?entries.*?{\"id\":\"([^\"]*?)\",\"name\":\"{$pregHost}\",\"type\":\"A\".*?\$/", $output, $hostID);
					$hostID = $hostID[1];
					preg_match("/^{\"succeeded\":true.*?domain_name\":\"{$pregDomain}.*?entries.*?{[^\}]*?\"name\":\"{$pregHost}\",\"type\":\"A\".*?content\":\"([^\"]*?)\".*?\$/", $output, $hostIP);
					$hostIP = $hostIP[1];
					unset($pregHost);
					unset($pregDomain);

					//step 3: update the IP
					if ($hostID) {
						curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
						curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 1);
						curl_setopt($ch, CURLOPT_COOKIE, $cookie_data);
						$post_data['content'] = $this->_dnsIP;
						curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);
						curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'PUT');
						curl_setopt($ch, CURLOPT_URL, "https://www.hover.com/api/dns/{$hostID}");
						log_error("HostID:{$hostID}, OldIP:{$hostIP}");
					}
					break;
				case 'onecom':
				case 'onecom-v6':
					/* see https://redmine.pfsense.org/issues/11293
					 * and https://redmine.pfsense.org/issues/12352 */

					curl_setopt($ch, CURLOPT_URL, "https://www.one.com/admin/");
					curl_setopt($ch, CURLOPT_HEADER, 1); //return the full headers to extract the cookies
					curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);
					curl_setopt($ch, CURLOPT_USERAGENT, $this->_UserAgent);
					curl_setopt($ch, CURLOPT_FORBID_REUSE, true);
					$output = curl_exec($ch);
					$last_url = curl_getinfo($ch, CURLINFO_EFFECTIVE_URL);

					// extract the cookies
					preg_match_all("/^Set-cookie: (.*?);/ism", $output, $cookies);
					if (count($cookies[1]) > 0) {
						$cookie_data = implode("; ", $cookies[1]);
					}

					// login in
					$post_data['username'] = $this->_dnsUser;
					$post_data['password'] = $this->_dnsPass;
					$post_data['credentialId'] = '';

					curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);
					curl_setopt($ch, CURLOPT_URL, $last_url);
					curl_setopt($ch, CURLOPT_COOKIE, $cookie_data);
					curl_setopt($ch, CURLOPT_HEADER, 1); //return the full headers to extract the cookies
					curl_setopt($ch, CURLOPT_USERAGENT, $this->_UserAgent);
					curl_setopt($ch, CURLOPT_FORBID_REUSE, true);
					$output = curl_exec($ch);

					// extract the cookies
					preg_match_all("/^Set-cookie: (.*?);/ism", $output, $cookies);
					if (count($cookies[1]) > 0) {
						$cookie_data = implode("; ", $cookies[1]);
					}

					// gets all DNS records of the domain.
					$post_data = null;
					$url = "https://www.one.com/admin/api/domains/" . $this->_dnsDomain + "/dns/custom_records";
					curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);
					curl_setopt($ch, CURLOPT_COOKIE, $cookie_data);
					curl_setopt($ch, CURLOPT_HEADER, 0);
					curl_setopt($ch, CURLOPT_URL, $url);
					curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'GET');
					curl_setopt($ch, CURLOPT_USERAGENT, $this->_UserAgent);
					curl_setopt($ch, CURLOPT_FORBID_REUSE, true);
					$output = curl_exec($ch);
					$result = json_decode($output, true);
					$records = $result['result']['data'];

					// finds the record id of a record from it's subdomain
					foreach ($records as $rec) {
						if ($rec['attributes']['prefix'] == $this->_dnsHostname) {
							$id = $rec['id'];
							break;
						}
					}
					if (!$id) {
						log_error("Could not find one.com hostname record id");
						return false;
					}

					// changes the IP Address of a TYPE A record. Default TTL=3800
					$tosend = array();
					$tosend['type'] = 'dns_service_records';
					$tosend['id'] = $id;
					if (is_ipaddrv4($this->_dnsIP)) {
						$rectype = 'A';
					} else {
						$rectype = 'AAAA';
					}
					$tosend['attributes'] = array(
						'type' => $rectype,
						'prefix' => $this->_dnsHostname,
						'content' => $this->_dnsIP,
						'ttl' => $this->_dnsTTL
					);
					$url = "https://www.one.com/admin/api/domains/" . $this->_dnsDomain .
						 "/dns/custom_records/" . $id;
					curl_setopt($ch, CURLOPT_URL, $url);
					curl_setopt($ch, CURLOPT_HTTPHEADER, array("Content-Type: application/json"));
					curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($tosend));
					curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'PATCH');
					curl_setopt($ch, CURLOPT_USERAGENT, $this->_UserAgent);
					break;
				case 'dreamhost':
				case 'dreamhost-v6':
					$needsIP = TRUE;
					$isv6 = ($this->_dnsService === 'dreamhost-v6');
					$server = 'https://api.dreamhost.com/';
					$post_data['key'] = $this->_dnsPass;
					$post_data['unique_id'] = uniqid($this->_dnsHost);
					$post_data['cmd'] = 'dns-add_record';
					$post_data['format'] = 'json';
					$post_data['value'] = $this->_dnsIP;
					$post_data['record'] = $this->_dnsHost;
					$post_data['type'] = $isv6 ? 'AAAA' : 'A';
					$post_data['comment'] = "Updated by pfSense:$this->_dnsUser on " . date('c');
					$port = "";
					if ($this->_dnsServer) {
						$server = $this->_dnsServer;
					}
					if ($this->_dnsPort) {
						$port = ":" . $this->_dnsPort;
					}
					curl_setopt($ch, CURLOPT_URL, $server . $port);
					curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);
					break;
				case 'digitalocean':
				case 'digitalocean-v6':
					// Get record ID
					$server = 'https://api.digitalocean.com/v2/domains/';
					$isv6 = ($this->_dnsService === 'digitalocean-v6');
					$url = $server . $this->_dnsDomain . '/records';
					curl_setopt($ch, CURLOPT_HTTPHEADER, array("Authorization: Bearer {$this->_dnsPass}"));
					curl_setopt($ch, CURLOPT_URL, $url);
					curl_setopt($ch, CURLOPT_FORBID_REUSE, true);
					$output = json_decode(curl_exec($ch));
					if (!is_array($output->domain_records)) {
						$output->domain_records = array();
					}

					// DO's API lists 20 NS records per page, so additional pages needs to be downloaded
					// https://redmine.pfsense.org/issues/10952
					$_domain_records = $output->domain_records;
					$_count = count($_domain_records);
					$_total = 0;
					if (property_exists($output, 'meta')) {
						$meta = $output->meta;
						if (property_exists($meta, 'total')) {
							$_total = $meta->total;
						}
					}
					$_next = '...';
					$_last = '';
					while ($_next != $_last) {
						$_next = '';
						if (property_exists($output, 'links')) {
							$_links = $output->links;
							if (property_exists($_links, 'pages')) {
								$_pages = $_links->pages;
								if (property_exists($_pages, 'next')) {
									$_next = $_pages->next;
								}
								if (property_exists($_pages, 'last')) {
									$_last = $_pages->last;
								}
								if ($_next != '') {
									echo "getting $_next\n";
									curl_setopt($ch, CURLOPT_URL, $_next);
									curl_setopt($ch, CURLOPT_FORBID_REUSE, true);
									$output = json_decode(curl_exec($ch));
									if (!is_array($output->domain_records)) {
										$output->domain_records = array();
									}
									$_domain_records = array_merge($_domain_records,$output->domain_records);
								}
							}
						}
					}
					$_count = count($_domain_records);

					foreach($_domain_records as $dnsRecord) {
						// NS records are named @ in DO's API, so check type as well
						// https://redmine.pfsense.org/issues/9171
						if ($this->_dnsHost == $dnsRecord->name && $dnsRecord->type == ($isv6 ? 'AAAA' : 'A')) {
							$recordID = $dnsRecord->id;
							break;
						}
					}

					// Create/update record
					if ($recordID == null) {
						$url = $server . $this->_dnsDomain . '/records';
					} else {
						$url = $server . $this->_dnsDomain . '/records/' . $recordID;
						curl_setopt($ch, CURLOPT_CUSTOMREQUEST, "PUT");
					}
					$post_data['type'] = $isv6 ? 'AAAA' : 'A';
					$post_data['ttl'] = $this->_dnsTTL;
					$post_data['name'] = $this->_dnsHost;
					$post_data['data'] = $this->_dnsIP;
					curl_setopt($ch, CURLOPT_URL, $url);
					curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);
					break;
				case 'cloudns':
					/* Uses ClouDNS REST API
					   Requires auth-id or sub-auth-id or sub-auth-user */
					// Step 1: Find the Record ID
					$url = 'https://api.cloudns.net/dns/records.json';
					$post_data['auth-id'] = $this->_dnsUser;
					$post_data['auth-password'] = $this->_dnsPass;
					$post_data['domain-name'] = $this->_dnsDomain;
					$post_data['host'] = $this->_dnsHost;
					$post_data['type'] = 'a';
					curl_setopt($ch, CURLOPT_URL, $url);
					curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);
					curl_setopt($ch, CURLOPT_FORBID_REUSE, true);
					$output = json_decode(curl_exec($ch));
					$recordID = key(get_object_vars($output));

					// Step 2: Set the record
					$needsIP = TRUE;
					$url = 'https://api.cloudns.net/dns/mod-record.json';
					$post_data = array();
					$post_data['auth-id'] = $this->_dnsUser;
					$post_data['auth-password'] = $this->_dnsPass;
					$post_data['domain-name'] = $this->_dnsDomain;
					$post_data['record-id'] = $recordID;
					$post_data['host'] = $this->_dnsHost;
					$post_data['record'] = $this->_dnsIP;
					$post_data['ttl'] = $this->_dnsTTL;
					curl_setopt($ch, CURLOPT_URL, $url);
					curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);
					break;
				case 'azurev6':
				case 'azure':
					$hostname = "{$this->_dnsHost}";
					$resourceid = trim($this->_dnsZoneID);
					$app_id = $this->_dnsUser;
					$client_secret = $this->_dnsPass;
					$newip = $this->_dnsIP;
					$newttl = $this->_dnsTTL;
						// ensure resourceid starts with / and has no trailing /
					$resourceid = '/' . trim($resourceid, '/');
						// extract subscription id from resource id
					preg_match('/\\/subscriptions\\/(?<sid>[^\\/]*)/', $resourceid, $result);
					$subscriptionid = isset($result['sid']) ? $result['sid'] : '';
					if (isset($result['sid'])) {
						$subscriptionid = $result['sid'];
					} else {
						log_error("Azure subscription id not found in resource id");
						return false;
					}
						// find tenant id from subscription id
					curl_setopt($ch, CURLOPT_URL, "https://management.azure.com/subscriptions/" . $subscriptionid . "?api-version=2016-09-01");
					curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
					curl_setopt($ch, CURLOPT_HEADER, 1);
					curl_setopt($ch, CURLOPT_NOBODY, 1);
					curl_setopt($ch, CURLOPT_FORBID_REUSE, true);
					$output = curl_exec($ch);
					$pattern = '/Bearer authorization_uri="https:\\/\\/login.windows.net\\/(?<tid>[^"]*)/i';
					preg_match($pattern, $output, $result);
					if (isset($result['tid'])) {
						$tenantid = $result['tid'];
					} else {
						log_error("Tenant ID not found");
						return false;
					}
						// get an bearer token
					curl_setopt($ch, CURLOPT_URL, "https://login.microsoftonline.com/" . $tenantid . "/oauth2/token");
					curl_setopt($ch, CURLOPT_POST, 1);
					$body = "resource=" . urlencode("https://management.core.windows.net/") . "&grant_type=client_credentials&client_id=" . $app_id . "&client_secret=" . urlencode($client_secret);
					curl_setopt($ch, CURLOPT_POSTFIELDS, $body);
					curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
					curl_setopt($ch, CURLOPT_FORBID_REUSE, true);
					$server_output = curl_exec($ch);
					$httpcode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
					preg_match("/\"access_token\":\"(?<tok>[^\"]*)\"/", $server_output, $result);
					if (isset($result['tok'])) {
						$bearertoken = $result['tok'];
					} else {
						log_error("no valid bearer token");
						return false;
					}
						// Update the DNS record
					if ($this->_useIPv6) {
						$url = "https://management.azure.com" . $resourceid . "/AAAA/" . $hostname . "?api-version=2017-09-01";
						$body = '{"properties":{"TTL":"' . $newttl . '", "AAAARecords":[{"ipv6Address":"' . $newip . '"}]}}';
					} else {
						$url = "https://management.azure.com" . $resourceid . "/A/" . $hostname . "?api-version=2017-09-01";
						$body = '{"properties":{"TTL":"' . $newttl . '", "ARecords":[{"ipv4Address":"' . $newip . '"}]}}';
					}
					$request_headers = array();
					$request_headers[] = 'Accept: application/json';
					$request_headers[] = 'Authorization: Bearer ' . $bearertoken;
					$request_headers[] = 'Content-Type: application/json';
					curl_setopt($ch, CURLOPT_URL, $url);
					curl_setopt($ch, CURLOPT_USERAGENT, $this->_UserAgent);
					curl_setopt($ch, CURLOPT_HTTPHEADER, $request_headers);
					curl_setopt($ch, CURLOPT_POSTFIELDS, $body);
					curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
					curl_setopt($ch, CURLOPT_HEADER, 1);
					curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'PUT');
					break;
				case 'linode':
				case 'linode-v6':
					$linode_api = "https://api.linode.com/v4";
					$record_type = $this->_useIPv6 ? "AAAA" : "A";
					$record_name = $this->_dnsHost == "@" ? "" : $this->_dnsHost;
					$err_prefix = gettext("Dynamic DNS") . " {$this->_dnsService} ({$this->_FQDN}): (" . gettext("Error") . ")";
					curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
					curl_setopt($ch, CURLOPT_HTTPHEADER, array(
						'Accept: application/json',
						'Content-Type: application/json',
						'Authorization: Bearer ' . $this->_dnsPass
					));

					// get domain id
					curl_setopt($ch, CURLOPT_URL, "{$linode_api}/domains");
					curl_setopt($ch, CURLOPT_FORBID_REUSE, true);
					$domains_output = curl_exec($ch);
					$http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);
					if ( $http_code == 401 && preg_match('/invalid oauth token/i', $domains_output) ) {
						log_error("$err_prefix " . gettext("querying domains") . ": " . gettext("User Authentication Failed"));
						return false;
					} else if ( $http_code == 401 ) {
						log_error("$err_prefix " . gettext("querying domains") . ": " . gettext("User Authorization Failed"));
						return false;
					} else if ( $http_code != 200 ) {
						log_error("$err_prefix " . gettext("querying domains") . ": " .
							( isset($domains_result["errors"][0]["reason"]) ? $domains_result["errors"][0]["reason"] : "HTTP {$http_code}" ) );
						return false;
					}

					$domains_result = json_decode($domains_output, TRUE);
					foreach($domains_result["data"] as $domains_entry) {
						if ($domains_entry["domain"] == $this->_dnsDomain) {
							$domain_id = $domains_entry["id"];
						}
					}
					if ( ! $domain_id ) {
						log_error("{$err_prefix} " . gettext("no domain ID for domain") . ": '{$this->_dnsDomain}'");
						return false;
					}
					if ($this->_dnsVerboseLog) {
						log_error("_update(): " . sprintf(gettext("found domain id: %s"), $domain_id));
					}

					// get existing record if present
					curl_setopt($ch, CURLOPT_URL, "{$linode_api}/domains/{$domain_id}/records");
					curl_setopt($ch, CURLOPT_FORBID_REUSE, true);
					$records_output = curl_exec($ch);
					$http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);
					if ( $http_code != 200 )
					{
						log_error("$err_prefix " . gettext("querying domains") . ": " .
							( isset($domains_result["errors"][0]["reason"]) ? $domains_result["errors"][0]["reason"] : "HTTP {$http_code}" ) );
						return false;
					}

					$records_result = json_decode($records_output, TRUE);
					foreach($records_result["data"] as $records_entry) {
						if ( $records_entry["type"] == $record_type && $records_entry["name"] == $record_name ) {
							// not adding support for pagination at this time, hope you have < 100 records!
							$record = $records_entry;
						}
					}
					if ($this->_dnsVerboseLog) {
						log_error("_update(): " . ( $record ? sprintf(gettext("found existing record id: %s"), $record["id"]) : gettext("no matching record found") ));
					}

					if (is_array($record)) {
						// update existing record
						$record["target"] = $this->_dnsIP;
						$record["ttl_sec"] = (int) $this->_dnsTTL; // linode may round this up, 0 = zone default
						curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($record));
						curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'PUT');
						curl_setopt($ch, CURLOPT_URL, "{$linode_api}/domains/{$domain_id}/records/" . $record["id"]);
					} else {
						// create a new record
						$record = array(
							"type"    => $record_type,
							"name"    => $record_name,
							"target"  => $this->_dnsIP,
							"ttl_sec" => (int) $this->_dnsTTL, // linode may round this up, 0 = zone default
						);
						curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($record));
						curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'POST');
						curl_setopt($ch, CURLOPT_URL, "{$linode_api}/domains/{$domain_id}/records");
					}
					break;
				case 'dynv6':
					$needIP = TRUE;
					curl_setopt($ch, CURLOPT_URL, 'https://dynv6.com/api/update?ipv4=' . $this->_dnsIP . '&hostname=' . $this->_dnsHost . '&token=' . $this->_dnsPass);
					break;
				case 'dynv6-v6':
					$needIP = TRUE;
					curl_setopt($ch, CURLOPT_URL, 'https://dynv6.com/api/update?ipv6=' . $this->_dnsIP . '&hostname=' . $this->_dnsHost . '&token=' . $this->_dnsPass);
					break;
				case 'gandi-livedns':
				case 'gandi-livedns-v6':
					// https://api.gandi.net/docs/livedns/#v5-livedns-domains-fqdn-records-rrset_name-rrset_type
					// PUT overrides the existing record or creates if none exists
					$gandi_api = 'https://api.gandi.net/v5/livedns/domains/';
					$record_type = $this->_useIPv6 ? "AAAA" : "A";
					$url = "{$gandi_api}{$this->_dnsDomain}/records/{$this->_dnsHost}/{$record_type}";

					$headers = array(
						'Authorization: Apikey ' . $this->_dnsPass,
						'Content-Type: application/json'
					);
					$body = array(
						"rrset_ttl"  => $this->_dnsTTL,
						"rrset_values" => array($this->_dnsIP),
					);

					curl_setopt($ch, CURLOPT_URL, $url);
					curl_setopt($ch, CURLOPT_CUSTOMREQUEST, "PUT");
					curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);
					curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($body));
					break;
				case 'desec':
					curl_setopt($ch, CURLOPT_URL, 'https://update.dedyn.io/?hostname=' . $this->_dnsHost);
					curl_setopt($ch, CURLOPT_HTTPHEADER, array('Authorization: Token ' . $this->_dnsPass));
					break;
				case 'desec-v6':
					curl_setopt($ch, CURLOPT_URL, 'https://update6.dedyn.io/?hostname=' . $this->_dnsHost);
					curl_setopt($ch, CURLOPT_HTTPHEADER, array('Authorization: Token ' . $this->_dnsPass));
					break;
				default:
					break;
			}
			if ($this->_dnsService != 'ods') {
				curl_setopt($ch, CURLOPT_HEADER, 1);
				if ($this->_curlProxy == true) {
					set_curlproxy($ch);
				}
				curl_setopt($ch, CURLOPT_FORBID_REUSE, true);
				$response = curl_exec($ch);
				$header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);
				$header = substr($response, 0, $header_size);
				$data = substr($response, $header_size);
				if ($this->_dnsVerboseLog) {
					foreach (explode(PHP_EOL, $header) as $hv) {
						log_error(sprintf("Response Header: %s", rtrim($hv)));
					}
					log_error(sprintf("Response Data: %s", $data));
				}
				$http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);
				$curl_error = @curl_error($ch);
				$this->_checkStatus($http_code, $curl_error, $data, $header);
			}
			if ($this->_dnsVerboseLog) {
				log_error(sprintf(gettext('Dynamic DNS %1$s (%2$s): _update() ending.'), $this->_dnsService, $this->_FQDN));
			}
		}

		/**
		 * Private Function (added 23 Feb 17)
		 *   Send Removal To Selected Service.
		 *
		 *   Some services do not perform an inplace upgrade.  If they do not then the solution
		 *   is to remove the existing record and add a new record.
		 *
		 * @param unknown $existing_ip If required, an existing IP address for the record.
		 */
		function _remove($existing_ip = NULL) {
			$remove_allowed = false;
			if ($this->_dnsVerboseLog) {
				log_error(sprintf(gettext('Dynamic DNS %1$s (%2$s): _remove() starting.'), $this->_dnsService, $this->_FQDN));
			}

			if (strstr($this->_dnsRequestIf, "_vip")) {
				$parentif = get_configured_vip_interface($this->_dnsRequestIf);
				$realparentif = convert_friendly_interface_to_real_interface_name($parentif);
			} else {
				$realparentif = $this->_dnsRequestIf;
			}

			$ch = curl_init();

			if ($this->_useIPv6 == false) {
				curl_setopt($ch, CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V4);
			}

			curl_setopt($ch, CURLOPT_USERAGENT, $this->_UserAgent);
			curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
			curl_setopt($ch, CURLOPT_INTERFACE, 'if!' . $realparentif);
			curl_setopt($ch, CURLOPT_TIMEOUT, 120); // Completely empirical

			switch ($this->_dnsService) {
			case 'dreamhost':
			case 'dreamhost-v6':
				$server = 'https://api.dreamhost.com/';
				$post_data['key'] = $this->_dnsPass;
				$post_data['unique_id'] = uniqid($this->_dnsHost);
				$post_data['cmd'] = 'dns-remove_record';
				$post_data['format'] = 'json';
				$post_data['value'] = $existing_ip;
				$post_data['record'] = $this->_dnsHost;
				$isv6 = ($this->_dnsService === 'dreamhost-v6');
				$post_data['type'] = $isv6 ? 'AAAA' : 'A';
				$port = "";
				if ($this->_dnsServer) {
					$server = $this->_dnsServer;
				}
				if ($this->_dnsPort) {
					$port = ":" . $this->_dnsPort;
				}
				curl_setopt($ch, CURLOPT_URL, $server . $port);
				curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);
				$remove_allowed = true;
				break;
			default:
				break;
			}
			if ($remove_allowed) {
				curl_setopt($ch, CURLOPT_HEADER, 1);
				curl_setopt($ch, CURLOPT_FORBID_REUSE, true);
				$response = curl_exec($ch);
				$header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);
				$header = substr($response, 0, $header_size);
				$data = substr($response, $header_size);
				$http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);
				$curl_error = @curl_error($ch);
				$this->_checkStatus($http_code, $curl_error, $data, $header);
			}
		}

		/**
		 * Private Function (added 23 Feb 17)
		 * Retrieves current DNS records from an external API source.
		 *
		 * Some services cannot perform new operations without the caller
		 * providing existing record information.
		 */
		function _lookup_current() {
			$lookup_allowed = false;
			if ($this->_dnsVerboseLog) {
				log_error(sprintf(gettext('Dynamic DNS %1$s (%2$s): _listCurrent() starting.'), $this->_dnsService, $this->_FQDN));
			}

			if (strstr($this->_dnsRequestIf, "_vip")) {
				$parentif = get_configured_vip_interface($this->_dnsRequestIf);
				$realparentif = convert_friendly_interface_to_real_interface_name($parentif);
			} else {
				$realparentif = $this->_dnsRequestIf;
			}

			$ch = curl_init();

			if ($this->_useIPv6 == false) {
				curl_setopt($ch, CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V4);
			}

			curl_setopt($ch, CURLOPT_USERAGENT, $this->_UserAgent);
			curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
			curl_setopt($ch, CURLOPT_INTERFACE, 'if!' . $realparentif);
			curl_setopt($ch, CURLOPT_TIMEOUT, 120); // Completely empirical

			switch ($this->_dnsService) {
			case 'dreamhost':
			case 'dreamhost-v6':
				$server = 'https://api.dreamhost.com/';
				$post_data['key'] = $this->_dnsPass;
				$post_data['unique_id'] = uniqid($this->_dnsHost);
				$post_data['cmd'] = 'dns-list_records';
				$post_data['format'] = 'json';
				$port = "";
				if ($this->_dnsServer) {
					$server = $this->_dnsServer;
				}
				if ($this->_dnsPort) {
					$port = ":" . $this->_dnsPort;
				}
				curl_setopt($ch, CURLOPT_URL, $server . $port);
				curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);
				$lookup_allowed = true;
				break;
			default:
				break;
			}
			if ($lookup_allowed) {
				curl_setopt($ch, CURLOPT_HEADER, 1);
				curl_setopt($ch, CURLOPT_FORBID_REUSE, true);
				$response = curl_exec($ch);
				$header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);
				$header = substr($response, 0, $header_size);
				$data = substr($response, $header_size);
				$http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);
				$curl_error = @curl_error($ch);
				$this->_checkLookupStatus($curl_error, $data, $header);
			}
		}

		/*
		 * Private Function (added 23 Feb 17)
		 *   Retrieve Lookup Status from the provided data and/or header
		 */
		function _checkLookupStatus($curl_error, $data, $header) {
			if ($this->_dnsVerboseLog) {
				log_error(sprintf(gettext('Dynamic DNS %1$s (%2$s): _checkLookupStatus() starting.'), $this->_dnsService, $this->_FQDN));
			}
			$success_str = "(" . gettext("Success") . ") ";
			$error_str = "(" . gettext("Error") . ") ";
			$status_intro = "phpDynDNS ({$this->_dnsHost}): ";

			if ($this->_dnsService != 'ods' && !empty($curl_error)) {
				$status = gettext("Curl error occurred:") . " {$curl_error}";
				log_error($status);
				$this->status = $status;
				return;
			}
			switch ($this->_dnsService) {
			case 'dreamhost':
			case 'dreamhost-v6':
				$result = json_decode($data,true);
				if($result["result"] != "success") {
					log_error($status_intro . gettext("PAYLOAD:") . " {$data}");
					$this->_debug($data);
					return;
				} else {
					foreach($result["data"] as $key => $row) {
						if($row["record"] == $this->_dnsHost &&
								(($row["type"] == "A" && !$this->_useIPv6)
										|| ($row["type"] == "AAAA" && $this->_useIPv6)
								)) {
							if($row["editable"] == 0) {
								log_error($status_intro . "host " . $this->_dnsHost . " is not editable.");
								continue;
							}
							$this->_existingRecords[]=array("record"=>$row["type"], "type"=>$row["type"], "existing_val"=>$row["value"]);
						}
					}
				}
				if (!is_array($this->_existingRecords)){
					if ($this->_dnsVerboseLog) {
						log_error(sprintf(gettext('Dynamic DNS %1$s (%2$s): _checkLookupStatus() ending.  No matching records found.'), $this->_dnsService, $this->_FQDN));
					}
				}
				break;
			default:
				break;
			}
		}

		/*
		 * Private Function (added 12 July 2005) [beta]
		 *   Retrieve Update Status
		 */
		function _checkStatus($http_code, $curl_error, $data, $header) {
			if ($this->_dnsVerboseLog) {
				log_error(sprintf(gettext('Dynamic DNS %1$s (%2$s): _checkStatus() starting.'), $this->_dnsService, $this->_FQDN));
			}
			$successful_update = false;
			$success_str = "(" . gettext("Success") . ") ";
			$error_str = "(" . gettext("Error") . ") ";
			$status_intro = "phpDynDNS ({$this->_dnsHost}): ";

			if ($this->_dnsService != 'ods' && !empty($curl_error)) {
				$status = gettext("Curl error occurred:") . " {$curl_error}";
				log_error($status);
				$this->status = $status;
				return;
			}
			switch ($this->_dnsService) {
				// The special custom provider
				case 'custom':
				case 'custom-v6':
					$successful_update = false;
					if ($this->_dnsResultMatch == "") {
						$successful_update = true;
					} else {
						$this->_dnsResultMatch = str_replace("%IP%", $this->_dnsIP, $this->_dnsResultMatch);
						$matches = preg_split("/(?<!\\\\)\\|/", $this->_dnsResultMatch);
						foreach ($matches as $match) {
							$match= str_replace("\\|", "|", $match);
							if (strcmp($match, trim($data, "\t\n\r")) == 0) {
								$successful_update = true;
							}
						}
						unset ($matches);
					}
					if ($successful_update == true) {
						$status = $status_intro . $success_str . gettext("IP Address Updated Successfully!");
					} else {
						$status = $status_intro . $error_str . gettext("Result did not match.") . " [" . $data . "]";
					}
					break;
				// Providers in an alphabetical order. Add code for new providers below in a correct position.
				case 'dyfi':
					// see specification at https://www.dy.fi/page/specification
					if (preg_match('/badauth/i', $data)) {
						$status = $status_intro . $error_str . gettext("User Authorization Failed");
					} else if (preg_match('/nohost/i', $data)) {
						$status = $status_intro . $error_str . gettext("No such host");
					} else if (preg_match('/notfqdn/i', $data)) {
						$status = $status_intro . $error_str . gettext("Not A FQDN!");
					} else if (preg_match('/badip/i', $data)) {
						$status = $status_intro . $error_str . gettext("Invalid IP. IP Address submitted is improperly formatted or is a private IP address or is on a blacklist.");
					} else if (preg_match('/nochg/i', $data)) {
						$status = $status_intro . $success_str . gettext("No Change In IP Address");
						$successful_update = true;
					} else if (preg_match('/good/i', $data)) {
						$status = $status_intro . $success_str . gettext("IP Address Changed Successfully!") . " (" . $this->_dnsIP . ")";
						$successful_update = true;
					} else if (preg_match('/dnserr/i', $data)) {
						$status = $status_intro . $error_str . gettext("Server side error.");
					} else if (preg_match('/abuse/i', $data)) {
						$status = $status_intro . $error_str . gettext("Updating too frequently, considered abuse.");
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " {$data}");
						$this->_debug($data);
					}
					break;
				case 'glesys':
					$status_intro = "GleSYS ({$this->_dnsHost}): ";
					if (preg_match("/OK/i", $data)) {
						$status = $status_intro . $success_str . gettext("IP Address Changed Successfully!") . " (" . $this->_dnsIP . ")";
						$successful_update = true;
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " {$data}");
						$this->_debug($data);
					}
					break;
				//
				// Not yet ordered providers.
				// TODO: When editing a provider, move it above in a correct position.
				//
				case 'dnsomatic':
					$status_intro = "DNS-O-Matic ({$this->_dnsHost}): ";
					if (preg_match('/badauth/i', $data)) {
						$status = $status_intro . gettext("The DNS-O-Matic username or password specified are incorrect. No updates will be distributed to services until this is resolved.");
					} else if (preg_match('/notfqdn /i', $data)) {
						$status = $status_intro . gettext("The hostname specified is not a fully-qualified domain name. If no hostnames included, notfqdn will be returned once.");
					} else if (preg_match('/nohost/i', $data)) {
						$status = $status_intro . gettext("The hostname passed could not be matched to any services configured. The service field will be blank in the return code.");
					} else if (preg_match('/numhost/i', $data)) {
						$status = $status_intro . gettext("Up to 20 hosts my be updated. numhost is returned if attempting to update more than 20 or update a round-robin.");
					} else if (preg_match('/abuse/i', $data)) {
						$status = $status_intro . gettext("The hostname is blocked for update abuse.");
					} else if (preg_match('/good/i', $data)) {
						$status = $status_intro . $success_str . gettext("IP Address Changed Successfully!") . " (" . $this->_dnsIP . ")";
						$successful_update = true;
					} else if (preg_match('/dnserr/i', $data)) {
						$status = $status_intro . gettext("DNS error encountered. Stop updating for 30 minutes.");
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " {$data}");
						$this->_debug($data);
					}
					break;
				case 'domeneshop':
				case 'domeneshop-v6':
					/* Responds with HTTP 204 on success.
					 * see https://api.domeneshop.no/docs/index.html#tag/ddns/paths/~1dyndns~1update/get */

					if ($http_code == "204") {
						$status = $status_intro . $success_str . gettext("IP Address Updated Successfully!");
						$successful_update = true;
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ": " . $http_code . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " " . $data);
						$this->_debug($data);
					}
					break;
				case 'onecom':
				case 'onecom-v6':

					if (($http_code == "200") || ($http_code == "204")) {
						$status = $status_intro . $success_str . gettext("IP Address Updated Successfully!");
						$successful_update = true;
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ": " . $http_code . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " " . $data);
						$this->_debug($data);
					}
					break;
				case 'citynetwork':
					if (preg_match('/notfqdn/i', $data)) {
						$status = $status_intro . $error_str . gettext("Not A FQDN!");
					} else if (preg_match('/nohost/i', $data)) {
						$status = $status_intro . $error_str . gettext("No such host");
					} else if (preg_match('/nochg/i', $data)) {
						$status = $status_intro . $success_str . gettext("No Change In IP Address");
						$successful_update = true;
					} else if (preg_match('/good/i', $data)) {
						$status = $status_intro . $success_str . gettext("IP Address Changed Successfully!") . " (" . $this->_dnsIP . ")";
						$successful_update = true;
					} else if (preg_match('/badauth/i', $data)) {
						$status = $status_intro . $error_str . gettext("User Authorization Failed");
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " {$data}");
						$this->_debug($data);
					}
					break;
				case 'ovh-dynhost':
				case 'dyndns':
					if (preg_match('/notfqdn/i', $data)) {
						$status = $status_intro . $error_str . gettext("Not A FQDN!");
					} else if (preg_match('/nochg/i', $data)) {
						$status = $status_intro . $success_str . gettext("No Change In IP Address");
						$successful_update = true;
					} else if (preg_match('/good/i', $data)) {
						$status = $status_intro . $success_str . gettext("IP Address Changed Successfully!") . " (" . $this->_dnsIP . ")";
						$successful_update = true;
					} else if (preg_match('/noauth/i', $data)) {
						$status = $status_intro . $error_str . gettext("User Authorization Failed");
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " {$data}");
						$this->_debug($data);
					}
					break;
				case 'dyndns-static':
					if (preg_match('/notfqdn/i', $data)) {
						$status = $status_intro . $error_str . gettext("Not A FQDN!");
					} else if (preg_match('/nochg/i', $data)) {
						$status = $status_intro . $success_str . gettext("No Change In IP Address");
						$successful_update = true;
					} else if (preg_match('/good/i', $data)) {
						$status = $status_intro . $success_str . gettext("IP Address Changed Successfully!");
						$successful_update = true;
					} else if (preg_match('/noauth/i', $data)) {
						$status = $status_intro . $error_str . gettext("User Authorization Failed");
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " {$data}");
						$this->_debug($data);
					}
					break;
				case 'dyndns-custom':
					if (preg_match('/notfqdn/i', $data)) {
						$status = $status_intro . $error_str . gettext("Not A FQDN!");
					} else if (preg_match('/nochg/i', $data)) {
						$status = $status_intro . $success_str . gettext("No Change In IP Address");
						$successful_update = true;
					} else if (preg_match('/good/i', $data)) {
						$status = $status_intro . $success_str . gettext("IP Address Changed Successfully!");
						$successful_update = true;
					} else if (preg_match('/noauth/i', $data)) {
						$status = $status_intro . $error_str . gettext("User Authorization Failed");
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " {$data}");
						$this->_debug($data);
					}
					break;
				case 'dhs':
					break;
				case 'noip':
				case 'noip-free':
					if (preg_match('/good/i', $data)) {
						$status = $status_intro . $success_str . gettext("IP Address Changed Successfully!");
						$successful_update = true;
					} else if (preg_match('/nochg/i', $data)) {
						$status = $status_intro . $success_str . gettext("No Change In IP Address");
						$successful_update = true;
					} else if (preg_match('/nohost/i', $data)) {
						$status = $status_intro . $error_str . gettext("Hostname supplied does not exist under specified account");
					} else if (preg_match('/badauth/i', $data)) {
						$status = $status_intro . $error_str . gettext("Invalid username password combination");
					} else if (preg_match('/badagent/i', $data)) {
						$status = $status_intro . $error_str . gettext("Client disabled");
					} else if (preg_match('/\!donator/i', $data)) {
						$status = $status_intro . $error_str . gettext("Feature is not available");
					} else if (preg_match('/abuse/i', $data)) {
						$status = $status_intro . $error_str . gettext("Username is blocked due to abuse");
					} else if (preg_match('/911/i', $data)) {
						$status = $status_intro . $error_str . gettext("Fatal error");
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " {$data}");
						$this->_debug($data);
					}
					break;
				case 'noip-v6':
				case 'noip-free-v6':
					list($ip, $code) = explode(":", $data);
					switch ($code) {
						case 0:
							$status = $status_intro . $success_str . gettext("IP address is current, no update performed.");
							$successful_update = true;
							break;
						case 1:
							$status = $status_intro . $success_str . gettext("DNS hostname update successful.");
							$successful_update = true;
							break;
						case 2:
							$status = $status_intro . $error_str . gettext("Hostname supplied does not exist.");
							break;
						case 3:
							$status = $status_intro . $error_str . gettext("Invalid Username.");
							break;
						case 4:
							$status = $status_intro . $error_str . gettext("Invalid Password.");
							break;
						case 5:
							$status = $status_intro . $error_str . gettext("Too many updates sent.");
							break;
						case 6:
							$status = $status_intro . $error_str . gettext("Account disabled due to violation of No-IP terms of service.");
							break;
						case 7:
							$status = $status_intro . $error_str . gettext("Invalid IP. IP Address submitted is improperly formatted or is a private IP address or is on a blacklist.");
							break;
						case 8:
							$status = $status_intro . $error_str . gettext("Disabled / Locked Hostname.");
							break;
						case 9:
							$status = $status_intro . $error_str . gettext("Host updated is configured as a web redirect and no update was performed.");
							break;
						case 10:
							$status = $status_intro . $error_str . gettext("Group supplied does not exist.");
							break;
						case 11:
							$status = $status_intro . $success_str . gettext("DNS group update is successful.");
							$successful_update = true;
							break;
						case 12:
							$status = $status_intro . $success_str . gettext("DNS group is current, no update performed.");
							$successful_update = true;
							break;
						case 13:
							$status = $status_intro . $error_str . gettext("Update client support not available for supplied hostname or group.");
							break;
						case 14:
							$status = $status_intro . $error_str . gettext("Hostname supplied does not have offline settings configured.");
							break;
						case 99:
							$status = $status_intro . $error_str . gettext("Client disabled. Client should exit and not perform any more updates without user intervention.");
							break;
						case 100:
							$status = $status_intro . $error_str . gettext("Client disabled. Client should exit and not perform any more updates without user intervention.");
							break;
						default:
							$status = $status_intro . "(" . gettext("Unknown Response") . ")";
							$this->_debug(gettext("Unknown Response:") . " " . $data);
							break;
					}
					break;
				case 'easydns':
					if (preg_match('/NOACCESS/i', $data)) {
						$status = $status_intro . $error_str . gettext("Authentication Failed: Username and/or Password was Incorrect.");
					} else if (preg_match('/NOSERVICE/i', $data)) {
						$status = $status_intro . $error_str . gettext("No Service: Dynamic DNS Service has been disabled for this domain.");
					} else if (preg_match('/ILLEGAL INPUT/i', $data)) {
						$status = $status_intro . $error_str . gettext("Illegal Input: Self-Explanatory");
					} else if (preg_match('/TOOSOON/i', $data)) {
						$status = $status_intro . $error_str . gettext("Too Soon: Not Enough Time Has Elapsed Since Last Update");
					} else if (preg_match('/NOERROR/i', $data)) {
						$status = $status_intro . $success_str . gettext("IP Updated Successfully!");
						$successful_update = true;
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " " . $data);
						$this->_debug($data);
					}
					break;
				case 'easydns-v6':
					if (preg_match('/NOACCESS/i', $data)) {
						$status = $status_intro . $error_str . gettext("Authentication Failed: Username and/or Password was Incorrect.");
					} else if (preg_match('/NOSERVICE/i', $data)) {
						$status = $status_intro . $error_str . gettext("No Service: Dynamic DNS Service has been disabled for this domain.");
					} else if (preg_match('/ILLEGAL INPUT/i', $data)) {
						$status = $status_intro . $error_str . gettext("Illegal Input: Self-Explanatory");
					} else if (preg_match('/TOOSOON/i', $data)) {
						$status = $status_intro . $error_str . gettext("Too Soon: Not Enough Time Has Elapsed Since Last Update");
					} else if (preg_match('/NOERROR/i', $data)) {
						$status = $status_intro . $success_str . gettext("IP Updated Successfully!");
						$successful_update = true;
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " " . $data);
						$this->_debug($data);
					}
					break;
				case 'hn':
					/* FIXME: add checks */
					break;
				case 'zoneedit':
					if (preg_match('/799/i', $data)) {
						$status = $status_intro . "(" . gettext("Error 799") . ") " . gettext("Update Failed!");
					} else if (preg_match('/700/i', $data)) {
						$status = $status_intro . "(" . gettext("Error 700") . ") " . gettext("Update Failed!");
					} else if (preg_match('/200/i', $data)) {
						$status = $status_intro . $success_str . gettext("IP Address Updated Successfully!");
						$successful_update = true;
					} else if (preg_match('/201/i', $data)) {
						$status = $status_intro . $success_str . gettext("IP Address Updated Successfully!");
						$successful_update = true;
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " " . $data);
						$this->_debug($data);
					}
					break;
				case 'dyns':
					if (preg_match("/400/i", $data)) {
						$status = $status_intro . $error_str . gettext("Bad Request - The URL was malformed. Required parameters were not provided.");
					} else if (preg_match('/402/i', $data)) {
						$status = $status_intro . $error_str . gettext("Update Too Soon - Attempted to update too quickly since last change.");
					} else if (preg_match('/403/i', $data)) {
						$status = $status_intro . $error_str . gettext("Database Error - There was a server-sided database error.");
					} else if (preg_match('/405/i', $data)) {
						$status = $status_intro . $error_str . sprintf(gettext('Hostname Error - The hostname (%1$s) doesn\'t belong to user (%2$s).'), $this->_dnsHost, $this->_dnsUser);
					} else if (preg_match('/200/i', $data)) {
						$status = $status_intro . $success_str . gettext("IP Address Updated Successfully!");
						$successful_update = true;
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " " . $data);
						$this->_debug($data);
					}
					break;
				case 'ods':
					if (preg_match("/299/i", $data)) {
						$status = $status_intro . $success_str . gettext("IP Address Updated Successfully!");
						$successful_update = true;
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " " . $data);
						$this->_debug($data);
					}
					break;
				case 'freedns':
				case 'freedns-v6':
					if (preg_match("/has not changed./i", $data)) {
						$status = $status_intro . $success_str . gettext("No Change In IP Address");
						$successful_update = true;
					} else if (preg_match("/Updated/i", $data)) {
						$status = $status_intro . $success_str . gettext("IP Address Changed Successfully!");
						$successful_update = true;
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " " . $data);
						$this->_debug($data);
					}
					break;
				case 'freedns2':
				case 'freedns2-v6':
					if (preg_match("/No IP change detected/i", $data)) {
						$status = $status_intro . $success_str . gettext("No Change In IP Address");
						$successful_update = true;
					} else if (preg_match("/Updated/i", $data)) {
						$status = $status_intro . $success_str . gettext("IP Address Changed Successfully!");
						$successful_update = true;
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " " . $data);
						$this->_debug($data);
					}
					break;
				case 'dnsexit':
					if (preg_match("/IP not changed/i", $data)) {
						$status = $status_intro . $success_str . gettext("No Change In IP Address");
						$successful_update = true;
					} else if (preg_match("/Success/i", $data)) {
						$status = $status_intro . $success_str . gettext("IP Address Changed Successfully!");
						$successful_update = true;
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " " . $data);
						$this->_debug($data);
					}
					break;
				case 'loopia':
					if (preg_match("/nochg/i", $data)) {
						$status = $status_intro . $success_str . gettext("No Change In IP Address");
						$successful_update = true;
					} else if (preg_match("/good/i", $data)) {
						$status = $status_intro . $success_str . gettext("IP Address Changed Successfully!");
						$successful_update = true;
					} else if (preg_match('/badauth/i', $data)) {
						$status = $status_intro . $error_str . gettext("User Authorization Failed");
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " " . $data);
						$this->_debug($data);
					}
					break;
				case 'opendns':
					if (preg_match('/badauth/i', $data)) {
						$status = $status_intro . $error_str . gettext("Not a valid username or password!");
					} else if (preg_match('/nohost/i', $data)) {
						$status = $status_intro . $error_str . gettext("Hostname specified does not exist.");
						$successful_update = true;
					} else if (preg_match('/good/i', $data)) {
						$status = $status_intro . $success_str . gettext("IP Address Changed Successfully!") . " (" . $this->_dnsIP . ")";
						$successful_update = true;
					} else if (preg_match('/yours/i', $data)) {
						$status = $status_intro . $error_str . gettext("Hostname specified exists, but not under the username specified.");
					} else if (preg_match('/abuse/i', $data)) {
						$status = $status_intro . $error_str . gettext("Updating too frequently, considered abuse.");
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " " . $data);
						$this->_debug($data);
					}
					break;
				case 'staticcling':
					if (preg_match("/invalid ip/i", $data)) {
						$status = $status_intro . $error_str . gettext("Bad Request - The IP provided was invalid.");
					} else if (preg_match('/required info missing/i', $data)) {
						$status = $status_intro . $error_str . gettext("Bad Request - Required parameters were not provided.");
					} else if (preg_match('/invalid characters/i', $data)) {
						$status = $status_intro . $error_str . gettext("Bad Request - Illegal characters in either the username or the password.");
					} else if (preg_match('/bad password/i', $data)) {
						$status = $status_intro . $error_str . gettext("Invalid password.");
					} else if (preg_match('/account locked/i', $data)) {
						$status = $status_intro . $error_str . gettext("This account has been administratively locked.");
					} else if (preg_match('/update too frequent/i', $data)) {
						$status = $status_intro . $error_str . gettext("Updating too frequently.");
					} else if (preg_match('/DB error/i', $data)) {
						$status = $status_intro . $error_str . gettext("Server side error.");
					} else if (preg_match('/success/i', $data)) {
						$status = $status_intro . $success_str . gettext("IP Address Updated Successfully!");
						$successful_update = true;
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " " . $data);
						$this->_debug($data);
					}
					break;
				case 'mythicbeasts':
				case 'mythicbeasts-v6':
					/* https://www.mythic-beasts.com/support/api/dnsv2/tutorial */
					$result = json_decode($data, true);
					if ($result['message'] == '1 records added') {
						$status = $status_intro . $success_str . gettext("IP Address Updated Successfully!");
						$successful_update = true;
					} else {
						log_error($status_intro . " ( " . gettext("Error message: ") . $result['error'] . " )");
					}
					break;
				case 'name.com':
				case 'name.com-v6':
					if ($http_code == "200") {
						$status = $status_intro . $success_str . gettext("IP Address Updated Successfully!");
						$successful_update = true;
					} else {
						$status = $status_intro . "(" . gettext("Error, HTTP response code") . ": " . $http_code . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " " . $data);
					}
					break;
				case 'namecheap':
					$tmp = str_replace("^M", "", $data);
					$ncresponse = @xml2array($tmp);
					/* If XML parsing failed, it may be due to unsupported encoding on the response. */
					if (empty($ncresponse)) {
						mb_convert_encoding($tmp, 'UTF-8', 'UTF-16');
						$tmp = str_ireplace('utf-16', 'utf-8', $tmp);
						$ncresponse = @xml2array($tmp);
					}
					/* If it's still empty, try parsing without the XML definition */
					if (empty($ncresponse)) {
						$matches = [];
						preg_match("/(<?xml.*?>)(.*)/", $tmp, $matches);
						if (count($matches) == 3) {
							$ncresponse = @xml2array($matches[2]);
						}
					}
					if (preg_match("/internal server error/i", $data)) {
						$status = $status_intro . $error_str . gettext("Server side error.");
					} else if (preg_match("/request is badly formed/i", $data)) {
						$status = $status_intro . $error_str . gettext("Badly Formed Request (check the settings).");
					} else if ($ncresponse['interface-response']['ErrCount'] === "0") {
						$status = $status_intro . $success_str . gettext("IP Address Updated Successfully!");
						$successful_update = true;
					} else if (is_numeric($ncresponse['interface-response']['ErrCount']) && ($ncresponse['interface-response']['ErrCount'] > 0)) {
						$status = $status_intro . $error_str . implode(", ", $ncresponse["interface-response"]["errors"]);
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " " . $data);
						$this->_debug($data);
					}
					break;
				case 'nicru':
				case 'nicru-v6':
					$status_intro = "NIC.RU ({$this->_dnsHost}): ";
					if (preg_match('/badauth/i', $data)) {
						$status = $status_intro . gettext("The NIC.RU username or password specified are incorrect.");
					} else if (preg_match('/notfqdn /i', $data)) {
						$status = $status_intro . gettext("The hostname specified is not a fully-qualified domain name.");
					} else if (preg_match('/nohost/i', $data)) {
						$status = $status_intro . gettext("The hostname passed could not be matched to any records configured.");
					} else if (preg_match('/good/i', $data)) {
						$status = $status_intro . $success_str . gettext("IP Address Changed Successfully!") . " (" . $this->_dnsIP . ")";
						$successful_update = true;
					} else if (preg_match('/dnserr/i', $data)) {
						$status = $status_intro . gettext("DNS error encountered. Stop updating for 30 minutes.");
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " {$data}");
						$this->_debug($data);
					}
					break;
				case 'duiadns':
				case 'duiadns-v6':
					if (preg_match("/error/i", $data)) {
						$status = $status_intro . $error_str . gettext("Server side error.");
					} else if (preg_match('/nohost/i', $data)) {
						$status = $status_intro . $error_str . gettext("Bad Request - A hostname was not provided.");
					} else if (preg_match('/badauth/i', $data)) {
						$status = $status_intro . $error_str . gettext("Invalid username or password.");
					} else if (preg_match('/good/i', $data)) {
						$status = $status_intro . $success_str . gettext("IP Address Updated Successfully!");
						$successful_update = true;
					} else if (preg_match('/nochg/i', $data)) {
						$status = $status_intro . $success_str . gettext("No Change In IP Address.");
						$successful_update = true;
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " " . $data);
						$this->_debug($data);
					}
					break;
				case 'he-net':
				case 'he-net-v6':
				case 'he-net-tunnelbroker':
					if (preg_match("/badip/i", $data)) {
						$status = $status_intro . $error_str . gettext("Bad Request - The IP provided was invalid.");
					} else if (preg_match('/nohost/i', $data)) {
						$status = $status_intro . $error_str . gettext("Bad Request - A hostname was not provided.");
					} else if (preg_match('/badauth/i', $data)) {
						$status = $status_intro . $error_str . gettext("Invalid username or password.");
					} else if (preg_match('/good/i', $data)) {
						$status = $status_intro . $success_str . gettext("IP Address Updated Successfully!");
						$successful_update = true;
					} else if (preg_match('/nochg/i', $data)) {
						$status = $status_intro . $success_str . gettext("No Change In IP Address.");
						$successful_update = true;
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " " . $data);
						$this->_debug($data);
					}
					break;
				case 'selfhost':
					if (preg_match('/notfqdn/i', $data)) {
						$status = $status_intro . $error_str . gettext("Not A FQDN!");
					} else if (preg_match('/nochg/i', $data)) {
						$status = $status_intro . $success_str . gettext("No Change In IP Address.");
						$successful_update = true;
					} else if (preg_match('/good/i', $data)) {
						$status = $status_intro . $success_str . gettext("IP Address Changed Successfully!") . " (" . $this->_dnsIP . ")";
						$successful_update = true;
					} else if (preg_match('/noauth/i', $data)) {
						$status = $status_intro . $error_str . gettext("User Authorization Failed");
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " " . $data);
						$this->_debug($data);
					}
					break;
				case 'strato':
					if (preg_match('/good\s' . $this->_dnsIP . '/i', $data)) {
						$status = $status_intro . $success_str . gettext("IP address updated successfully") . " (" . $this->_dnsIP . ")";
						$successful_update = true;
					} else if (preg_match('/good/i', $data)) {
						$status = $status_intro . $error_str . gettext("IP result did not match");
					} else if (preg_match('/nochg/i', $data)) {
						$status = $status_intro . $success_str . gettext("IP was not changed");
						$successful_update = true;
					} else if (preg_match("/badauth/i", $data)) {
						$status = $status_intro . $error_str . gettext("invalid username or password");
					} else if (preg_match('/nohost/i', $data)) {
						$status = $status_intro . $error_str . gettext("invalid hostname");
					} else if (preg_match('/abuse/i', $data)) {
						$status = $status_intro . $error_str . gettext("too many requests - please wait");
					} else {
						$status = $status_intro . "(" . gettext("unknown response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " " . $header . $data);
						$this->_debug($data);
						$this->_debug($header);
					}
					break;
				case 'route53':
				case 'route53-v6':
					if(preg_match('/ErrorResponse/', $data)){
						$status = $status_intro . $error_str . gettext("Route53 API call failed");
						log_error(sprintf("error message: %s", $data));
						$status_update = false;
					} else {
						$status = $status_intro . $success_str . gettext("IP address changed successfully");
						$successful_update = true;
					}
					break;
				case 'cloudflare-v6':
				case 'cloudflare':
					$output = json_decode($data);
					if ($output->result->content === $this->_dnsIP) {
						$status = $status_intro . $success_str . sprintf(gettext('%1$s updated to %2$s'), $this->_dnsHost, $this->_dnsIP);
						$successful_update = true;
					} elseif ($output->errors[0]->code === 9103) {
						$status = $status_intro . $error_str . gettext("Invalid Credentials! Don't forget to use API Key for password field with Cloudflare.");
					} elseif (($output->success) && (!$output->result[0]->id)) {
						$status = $status_intro . $error_str . gettext("Zone or Host ID was not found, check the hostname.");
					} else {
						$status = $status_intro . gettext("UNKNOWN ERROR") . " - " . $output->errors[0]->message;
						log_error($status_intro . gettext("PAYLOAD:") . " " . $data);
					}
					break;
				case 'yandex-v6':
				case 'yandex':
					$result = json_decode($data, true);
					if ($result['success'] == 'ok') {
						$successful_update = true;
					} elseif ($result['error'] == 'bad_domain') {
						log_error($status_intro . $error_str .  gettext("The domain name was not specified or does not conform to the RFC"));
					} elseif ($result['error'] == 'unknown') {
						log_error($status_intro . $error_str .  gettext("A temporary failure or API error occurred"));
					} elseif ($result['error'] == 'prohibited') {
						log_error($status_intro . $error_str .  gettext("A forbidden domain name"));
					} elseif ($result['error'] == 'bad_token') {
						log_error($status_intro . $error_str .  gettext("Invalid PDD token"));
					} elseif ($result['error'] == 'no_auth') {
						log_error($status_intro . $error_str .  gettext("The PddToken header was omitted"));
					} elseif ($result['error'] == 'not_allowed') {
						log_error($status_intro . $error_str .  gettext("This operation is not allowed for this user"));
					} elseif ($result['error'] == 'blocked') {
						log_error($status_intro . $error_str .  gettext("Blocked domain"));
					} elseif ($result['error'] == 'occupied') {
						log_error($status_intro . $error_str .  gettext("The domain name is in use by another user"));
					} elseif ($result['error'] == 'domain_limit_reached') {
						log_error($status_intro . $error_str .  gettext("Exceeded the acceptable number of connected domains (50)"));
					} elseif ($result['error'] == 'no_reply') {
						log_error($status_intro . $error_str .  gettext("Yandex.Mail for Domain cannot connect to the server source for the import"));
					} else {
						log_error($status_intro . $error_str .  gettext("PAYLOAD:") . " " . $data);
					}
					break;
				case 'eurodns':
					if (preg_match('/notfqdn/i', $data)) {
						$status = $status_intro . $error_str . gettext("Not A FQDN!");
					} else if (preg_match('/nochg/i', $data)) {
						$status = $status_intro . $success_str . gettext("No Change In IP Address");
						$successful_update = true;
					} else if (preg_match('/good/i', $data)) {
						$status = $status_intro . $success_str . gettext("IP Address Changed Successfully!") . " (" . $this->_dnsIP . ")";
						$successful_update = true;
					} else if (preg_match('/badauth/i', $data)) {
						$status = $status_intro . $error_str . gettext("User Authorization Failed");
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " " . $data);
						$this->_debug($data);
					}
					break;
				case 'gratisdns':
					if (preg_match('/Forkerte vÃ¦rdier/i', $data)) {
						$status = $status_intro . $error_str . gettext("Wrong values - Update could not be completed.");
					} else if (preg_match('/Bruger login: Bruger eksistere ikke/i', $data)) {
						$status = $status_intro . $error_str . gettext("Unknown username - User does not exist.");
					} else if (preg_match('/Bruger login: 1Fejl i kodeord/i', $data)) {
						$status = $status_intro . $error_str . gettext("Wrong password - Remember password is case sensitive.");
					} else if (preg_match('/DomÃ¦ne kan IKKE administreres af bruger/i', $data)) {
						$status = $status_intro . $error_str . gettext("User unable to administer the selected domain.");
					} else if (preg_match('/OK/i', $data)) {
						$status = $status_intro . $success_str . gettext("IP Address Updated Successfully!");
						$successful_update = true;
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " " . $data);
						$this->_debug($data);
					}
					break;
				case 'digitalocean':
				case 'digitalocean-v6':
					// Creating new records returns an HTTP 201, updating existing records get 200
					// https://redmine.pfsense.org/issues/9171
					if (preg_match("/HTTP\/2\s20[0,1]/i", $header)) {
						$status = $status_intro . $success_str . gettext("IP Address Updated Successfully!");
						$successful_update = true;
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " " . $data);
						$this->_debug($data);
					}
					break;
				case 'dnsimple':
				case 'dnsimple-v6':
					/* Responds with HTTP 200 on success.
					   Responds with HTTP 4xx on error.
					   Returns JSON data as body */
;
					if ($http_code == "200") {
						$status = $status_intro . $success_str . gettext("IP Address Updated Successfully!");
						$successful_update = true;
					} else if (preg_match("/4\d\d/i", $http_code)) {
						$arrbody = json_decode($data, true);
						$message = $arrbody['message'] . ".";
						if (isset($arrbody['errors']['content'])) {
							foreach ($arrbody['errors']['content'] as $key => $content) {
								$message .= " " . $content . ".";
							}
						}
						$status = $status_intro . $error_str . $message;
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ": " . $http_code . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " " . $data);
						$this->_debug($data);
					}
					break;
				case 'godaddy':
				case 'godaddy-v6':
					/* Responds with HTTP 200 on success.
					   Responds with HTTP 4xx or  on error.
					   Returns JSON data as body */
;
					if (preg_match("/\s200\sOK/i", $header)) {
						$status = $status_intro . $success_str . gettext("IP Address Updated Successfully!");
						$successful_update = true;
					} else if (preg_match("/\s4\d\d\s/i", $header)) {
						$arrbody = json_decode($data, true);
						$message = $arrbody['message'] . ".";
						if (isset($arrbody['fields'])) {
							foreach ($arrbody['fields'] as $error) {
								$message .= " " . $error['path'] . ": " . $error['message'] . ".";
							}
						}
						$status = $status_intro . $error_str . $message;
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " " . $data);
						$this->_debug($data);
					}
					break;
				case 'googledomains':
					if (preg_match('/notfqdn/i', $data)) {
						$status = $status_intro . $error_str . gettext("Not A FQDN");
					} else if (preg_match('/nochg/i', $data)) {
						$status = $status_intro . $success_str . gettext("No Change In IP Address");
						$successful_update = true;
					} else if (preg_match('/good/i', $data)) {
						$status = $status_intro . $success_str . gettext("IP Address Changed Successfully!") . " (" . $this->_dnsIP . ")";
						$successful_update = true;
					} else if (preg_match('/badauth/i', $data)) {
						$status = $status_intro . $error_str . gettext("User Authorization Failed");
					} else if (preg_match('/nohost/i', $data)) {
						$status = $status_intro . $error_str . gettext("Hostname does not exist or DynDNS not enabled");
					} else if (preg_match('/badagent/i', $data)) {
						$status = $status_intro . $error_str . gettext("Bad request");
					} else if (preg_match('/abuse/i', $data)) {
						$status = $status_intro . $error_str . gettext("Dynamic DNS access has been blocked!");
					} else if (preg_match('/911/i', $data)) {
						$status = $status_intro . $error_str . gettext("Error on Google's end, retry in 5 minutes");
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " " . $data);
						$this->_debug($data);
					}
					break;
				case 'dnsmadeeasy':
					switch ($data) {
						case 'success':
							$status = $status_intro . $success_str . gettext("IP Address Changed Successfully!") . " (" . $this->_dnsIP . ")";
							$successful_update = true;
							break;
						case 'error-auth':
							$status = $status_intro . $error_str . gettext("Invalid username or password");
							break;
						case 'error-auth-suspend':
							$status = $status_intro . $error_str . gettext("Account suspended");
							break;
						case 'error-auth-voided':
							$status = $status_intro . $error_str . gettext("Account revoked");
							break;
						case 'error-record-invalid':
							$status = $status_intro . $error_str . gettext("Record does not exist in the system. Unable to update record");
							break;
						case 'error-record-auth':
							$status = $status_intro . $error_str . gettext("User does not have access to this record");
							break;
						case 'error-record-ip-same':
							$status = $status_intro . $success_str . gettext("No Change In IP Address");
							$successful_update = true;
							break;
						case 'error-system':
							$status = $status_intro . $error_str . gettext("General system error recognized by the system");
							break;
						case 'error':
							$status = $status_intro . $error_str . gettext("General system error unrecognized by the system");
							break;
						default:
							$status = $status_intro . "(" . gettext("Unknown Response") . ")";
							log_error($status_intro . gettext("PAYLOAD:") . " " . $data);
							$this->_debug($data);
							break;
					}
					break;
				case 'spdyn':
				case 'spdyn-v6':
					if (preg_match('/notfqdn/i', $data)) {
						$status = $status_intro . $error_str . gettext("Not A FQDN!");
					} else if (preg_match('/nohost/i', $data)) {
						$status = $status_intro . $error_str . gettext("No such host");
					} else if (preg_match('/nochg/i', $data)) {
						$status = $status_intro . $success_str . gettext("No Change In IP Address");
						$successful_update = true;
					} else if (preg_match('/good/i', $data)) {
						$status = $status_intro . $success_str . gettext("IP Address Changed Successfully!") . " (" . $this->_dnsIP . ")";
						$successful_update = true;
					} else if (preg_match('/badauth/i', $data)) {
						$status = $status_intro . $error_str . gettext("User Authorization Failed");
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " " . $data);
						$this->_debug($data);
					}
					break;
				case 'all-inkl':
 					if (preg_match('/good\s' . $this->_dnsIP . '/i', $data)) {
							$status = $status_intro . $success_str . gettext("IP Address Changed Successfully!") . " (" . $this->_dnsIP . ")";
 							$successful_update = true;
 					} else if (preg_match('/good/i', $data)) {
						$status = $status_intro . $error_str . gettext("Result did not match.");
					} else if (preg_match("/\s401\sUnauthorized/i", $header)) {
						$status = $status_intro . $error_str . gettext("Invalid username or password");
					}
					else {
							$status = $status_intro . "(" . gettext("Unknown Response") . ")";
							log_error($status_intro . gettext("PAYLOAD:") . " " . $header . $data);
 							$this->_debug($data);
 							$this->_debug($header);
 					}
 					break;
				case 'hover':
					if (preg_match('/succeeded":true/i', $data)) {
						$status = $status_intro . $success_str . gettext("IP Address Changed Successfully!") . " (" . $this->_dnsIP . ")";
						$successful_update = true;
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " " . $data);
						$this->_debug($data);
					}
					break;
				case 'cloudns':
					$result = json_decode($data, true);
					if ($result['status'] == 'Success') {
						$successful_update = true;
					} else {
						log_error($result['status'] . "(" . $result['statusDescription'] . ")");
					}
					break;
				case 'dreamhost':
				case 'dreamhost-v6':
					$result = json_decode($data,true);
					if ($this->_dnsVerboseLog) {
						log_error(sprintf(gettext('_checkStatus() results: %1$s'), $data));
					}
					switch ($result['data']) {
					case 'success':
					case 'record_added':
					case 'record_removed':
						$status = $status_intro . $success_str . gettext("IP Address Changed Successfully!") . " (" . $this->_dnsIP . ")";
						$successful_update = true;
						break;
					case 'no_record':
					case 'no_such_record ':
						$status = $status_intro . $error_str . gettext("No record exists.");
						break;
					case 'no_type':
					case 'no_such_type ':
						$status = $status_intro . $error_str . gettext("No type exists.");
						break;
					case 'no_value':
					case 'no_such_value ':
						$status = $status_intro . $error_str . gettext("No value exists.");
						break;
					case 'no_such_zone':
						$status = $status_intro . $error_str . gettext("No such zone exists.");
						break;
					case 'invalid_record':
						$status = $status_intro . $error_str . gettext("The specified record is invalid.");
						break;
					case 'invalid_type':
						$status = $status_intro . $error_str . gettext("The specified type is invalid.");
						break;
					case 'invalid_value':
						$status = $status_intro . $error_str . gettext("The specified value is invalid.");
						break;
					case 'not_editable ':
						$status = $status_intro . $error_str . gettext("Record is not editable.");
						break;
					case 'record_already_exists_not_editable':
						$status = $status_intro . $error_str . gettext("Record exists but is not editable.");
						break;
					case 'record_already_exists_remove_first':
						$status = $status_intro . $error_str . gettext("Record exists and must be removed before adding.");
						break;
					case 'internal_error_updating_zone':
						$status = $status_intro . $error_str . gettext("A remote server error occurred updating the zone.");
						break;
					case 'internal_error_could_not_load_zone':
						$status = $status_intro . $error_str . gettext("A remote server error occurred loading the zone.");
						break;
					case 'internal_error_could_not_update_zone':
						$status = $status_intro . $error_str . gettext("A remote server error occurred updating the zone.");
						break;
					case 'internal_error_could_not_add_record':
						$status = $status_intro . $error_str . gettext("A remote server error occurred adding a new record.");
						break;
					case 'internal_error_could_not_destroy_record ':
						$status = $status_intro . $error_str . gettext("A remote server error occurred removing an existing record.");
						break;
					default:
						break;
					}
				case 'azure':
				case 'azurev6':
					if ($http_code == 401) {
						$status = $status_intro . $error_str . gettext("User Authorization Failed");
					} else if ($http_code == 201) {
						$status = $status_intro . $success_str . gettext("IP Address Changed Successfully!");
						$successful_update = true;
					} else if ($http_code == 200) {
						$status = $status_intro . $success_str . gettext("IP Address Changed Successfully!");
						$successful_update = true;
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " " . $http_code);
						$this->_debug($data);
					}
					break;
				case 'linode':
				case 'linode-v6':
					$status_intro = gettext("Dynamic DNS") . " {$this->_dnsService} ({$this->_FQDN}): ";
					$result = json_decode($data,true);
					if ($this->_dnsVerboseLog) {
						log_error(sprintf(gettext('_checkStatus() results: %1$s'), $data));
					}
					if ($http_code == 200 && isset($result["id"]) && ! isset($result["errors"])) {
						$status = $status_intro . $success_str . gettext("IP Address Changed Successfully!");
						$successful_update = true;
					} else if ( $http_code == 401 && preg_match('/not authorized to use/i', $data) ) {
						$status = $status_intro . $error_str . gettext("User Authorization Failed");
					} else {
						$status = $status_intro . $error_str .
							( isset($domains_result["errors"][0]["reason"]) ? $domains_result["errors"][0]["reason"] : "HTTP {$http_code}" );
					}
					break;
				case 'gandi-livedns':
				case 'gandi-livedns-v6':
					if ($http_code == 401) {
						$status = $status_intro . $error_str . gettext("User Authorization Failed");
					} else if ($http_code == 200 || $http_code == 201) {
						$status = $status_intro . $success_str . gettext("IP Address Changed Successfully!");
						$successful_update = true;
					} else {
						$status = $status_intro . "(" . gettext("Unknown Response") . ")";
						log_error($status_intro . gettext("PAYLOAD:") . " " . $http_code);
						$this->_debug($data);
					}
					break;
				case 'desec':
				case 'desec-v6':
					switch ($http_code) {
						case '200':
							$status = $status_intro . $success_str . gettext("IP Address Changed Successfully!");
							$successful_update = true;
							break;
						case '401':
							$status = $status_intro . $error_str . gettext("User Authorization Failed");
							break;
						default:
							$status = $status_intro . "(" . gettext("Unknown Response") . ")";
							log_error($status_intro . gettext("PAYLOAD:") . " " . $data);
							$this->_debug($data);
							break;
					}
					break;
				case 'dynv6':
					switch ($http_code) {
						case '200':
							$status = $status_intro . $success_str . gettext("IP Address Changed Successfully!");
							$successful_update = true;
							break;
						case '401':
							$status = $status_intro . $error_str . gettext("User Authorization Failed");
							break;
						default:
							$status = $status_intro . "(" . gettext("Unknown Response") . ")";
							log_error($status_intro . gettext("PAYLOAD:") . " " . $data);
							$this->_debug($data);
							break;
					}
					break;
				default:
					break;
			}

			if ($successful_update == true) {
				/* Write WAN IP to cache file */
				$wan_ip = $this->_checkIP();
				if ($this->_useIPv6 == false && $wan_ip > 0) {
					$currentTime = time();
					notify_all_remote(sprintf(gettext('DynDNS updated IP Address on %1$s (%2$s) to %3$s'), convert_real_interface_to_friendly_descr($this->_if), $this->_if, $wan_ip));
					log_error(sprintf(gettext('phpDynDNS: updating cache file %1$s: %2$s'), $this->_cacheFile, $wan_ip));
					@file_put_contents($this->_cacheFile, "{$wan_ip}|{$currentTime}");
				} else {
					@unlink($this->_cacheFile);
				}
				if ($this->_useIPv6 == true && $wan_ip > 0) {
					$currentTime = time();
					notify_all_remote(sprintf(gettext('DynDNS updated IPv6 Address on %1$s (%2$s) to %3$s'), convert_real_interface_to_friendly_descr($this->_if), $this->_if, $wan_ip));
					log_error(sprintf(gettext('phpDynDNS: updating cache file %1$s: %2$s'), $this->_cacheFile_v6, $wan_ip));
					@file_put_contents($this->_cacheFile_v6, "{$wan_ip}|{$currentTime}");
				} else {
					@unlink($this->_cacheFile_v6);
				}
			}
			$this->status = $status;
			log_error($status);
			if ($this->_dnsVerboseLog) {
				log_error(sprintf(gettext('Dynamic DNS %1$s (%2$s): _checkStatus() ending.'), $this->_dnsService, $this->_FQDN));
			}
		}

		/*
		 * Private Function (added 12 July 05) [beta]
		 *   Return Error, Set Last Error, and Die.
		 */
		function _error($errorNumber = '1') {
			$err_str = 'phpDynDNS: (' . gettext('ERROR!') . ') ';
			$err_str_r53 = 'Route 53: (' . gettext('Error') . ') ';
			switch ($errorNumber) {
				case 0:
					break;
				case 2:
					$error = $err_str . gettext('No Dynamic DNS Service provider was selected.');
					break;
				case 3:
					$error = $err_str . gettext('No Username Provided.');
					break;
				case 4:
					$error = $err_str . gettext('No Password Provided.');
					break;
				case 5:
					$error = $err_str . gettext('No Hostname Provided.');
					break;
				case 6:
					$error = $err_str . gettext('The Dynamic DNS Service provided is not yet supported.');
					break;
				case 7:
					$error = $err_str . gettext('No Update URL Provided.');
					break;
				case 8:
					$status = $err_str_r53 . gettext("Invalid ZoneID");
					break;
				case 9:
					$status = $err_str_r53 . gettext("Invalid TTL");
					break;
				case 10:
					$error = "phpDynDNS ({$this->_FQDN}): " . sprintf(gettext("No change in my IP address and/or %s days has not passed. Not updating dynamic DNS entry."), $this->_dnsMaxCacheAgeDays);
					break;
				default:
					$error = $err_str . gettext('Unknown Response.');
					/* FIXME: $data isn't in scope here */
					/* $this->_debug($data); */
					break;
			}
			$this->lastError = $error;
			log_error($error);
		}

		/*
		 * Private Function (added 12 July 05) [beta]
		 *   - Detect whether or not IP needs to be updated.
		 *      | Written Specifically for pfSense (https://www.pfsense.org) may
		 *      | work with other systems. pfSense base is FreeBSD.
		 */
		function _detectChange() {
			if ($this->_dnsVerboseLog) {
				log_error(sprintf(gettext('Dynamic DNS %1$s (%2$s): _detectChange() starting.'), $this->_dnsService, $this->_FQDN));
			}

			$currentTime = time();

			$wan_ip = $this->_checkIP();
			if ($wan_ip == 0) {
				log_error(sprintf(gettext("Dynamic Dns (%s): Current WAN IP could not be determined, skipping update process."), $this->_FQDN));
				return false;
			}
			$log_error = sprintf(gettext('Dynamic Dns (%1$s): Current WAN IP: %2$s'), $this->_FQDN, $wan_ip) . " ";

			if ($this->_useIPv6 == true) {
				if (file_exists($this->_cacheFile_v6)) {
					$contents = file_get_contents($this->_cacheFile_v6);
					list($cacheIP, $cacheTime) = explode('|', $contents);
					$this->_debug($cacheIP . '/' . $cacheTime);
					$initial = false;
					$log_error .= sprintf(gettext("Cached IPv6: %s"), $cacheIP);
				} else {
					$cacheIP = '::';
					@file_put_contents($this->_cacheFile, "::|{$currentTime}");
					$cacheTime = $currentTime;
					$initial = true;
					$log_error .= gettext("No Cached IPv6 found.");
				}
			} else {
				if (file_exists($this->_cacheFile)) {
					$contents = file_get_contents($this->_cacheFile);
					list($cacheIP, $cacheTime) = explode('|', $contents);
					$this->_debug($cacheIP . '/' . $cacheTime);
					$initial = false;
					$log_error .= sprintf(gettext("Cached IP: %s"), $cacheIP);
				} else {
					$cacheIP = '0.0.0.0';
					@file_put_contents($this->_cacheFile, "0.0.0.0|{$currentTime}");
					$cacheTime = $currentTime;
					$initial = true;
					$log_error .= gettext("No Cached IP found.");
				}
			}
			if ($this->_dnsVerboseLog) {
				log_error($log_error);
			}

			// Convert seconds = days * hr/day * min/hr * sec/min
			// We subtract 1 hour, so that when this code is executed few seconds
			// before _dnsMaxCacheAgeDays has passed, then we still consider that
			// a required number of days has passed.
			$maxCacheAgeSecs = $this->_dnsMaxCacheAgeDays * 24 * 60 * 60 - 60 * 60;

			$needs_updating = FALSE;
			/* lets determine if the item needs updating */
			if ($cacheIP != $wan_ip) {
				$needs_updating = true;
				$update_reason = gettext("Dynamic Dns: cacheIP != wan_ip. Updating.") . " ";
				$update_reason .= sprintf(gettext('Cached IP: %1$s WAN IP: %2$s'), $cacheIP, $wan_ip) . " ";
			}
			if (($currentTime - $cacheTime) > $maxCacheAgeSecs) {
				$needs_updating = true;
				$this->_forceUpdateNeeded = true;
				$update_reason = sprintf(gettext("Dynamic Dns: More than %s days. Updating."), $this->_dnsMaxCacheAgeDays);
				$update_reason .= " {$currentTime} - {$cacheTime} > {$maxCacheAgeSecs} ";
			}
			if ($initial == true) {
				$needs_updating = true;
				$update_reason .= gettext("Initial update.");
			}

			/*   finally if we need updating then store the
			 *   new cache value and return true
			 */
			if ($needs_updating == true) {
				if ($this->_dnsVerboseLog) {
					log_error("DynDns ({$this->_FQDN}): {$update_reason}");
				}
				return true;
			}

			return false;
		}

		/*
		 * Private Function (added 16 July 05) [beta]
		 *   - Writes debug information to a file.
		 *   - This function is only called when a unknown response
		 *   - status is returned from a DynDNS service provider.
		 */
		function _debug($data) {
			global $g;

			if (!$g['debug']) {
				return;
			}
			$string = date('m-d-y h:i:s') . ' - (' . $this->_debugID . ') - [' . $this->_dnsService . '] - ' . $data . "\n";
			$file = fopen($this->_debugFile, 'a');
			fwrite($file, $string);
			fclose($file);
		}
		function _checkIP() {
			if ($this->_dnsVerboseLog) {
				log_error(sprintf(gettext('Dynamic DNS %1$s (%2$s): _checkIP() starting.'), $this->_dnsService, $this->_FQDN));
			}

			if ($this->_useIPv6 == true) {
				$ip_address = get_interface_ipv6($this->_if);
				if (!is_ipaddrv6($ip_address)) {
					return 0;
				}
			} else {
				$ip_address = dyndnsCheckIP($this->_if);
				if (!is_ipaddr($ip_address)) {
					log_error(sprintf(gettext('Dynamic DNS %1$s (%2$s): IP address could not be extracted from Check IP Service'), $this->_dnsService, $this->_FQDN));
					return 0;
				} elseif (is_private_ip($ip_address)) {
					log_error(sprintf(gettext('Dynamic DNS %1$s (%2$s): Public IP address could not be extracted from Check IP Service'), $this->_dnsService, $this->_FQDN));
					return 0;
				}
			}
			if ($this->_useIPv6 == false && is_private_ip(get_interface_ip($this->_if))) {
				if ($this->_dnsVerboseLog) {
					log_error(sprintf(gettext('Dynamic DNS %1$s (%2$s): %3$s extracted from Check IP Service'), $this->_dnsService, $this->_FQDN, $ip_address));
				}
			} else {
				if ($this->_dnsVerboseLog) {
					log_error(sprintf(gettext('Dynamic DNS %1$s (%2$s): %3$s extracted from local system.'), $this->_dnsService, $this->_FQDN, $ip_address));
				}
			}
			$this->_dnsIP = $ip_address;

			return $ip_address;
		}

	}

?>
