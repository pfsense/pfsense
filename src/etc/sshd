#!/usr/local/bin/php-cgi -f
<?php
/*
 * sshd
 *
 * part of pfSense (https://www.pfsense.org)
 * Copyright (c) 2004 Fred Mol <fredmol@xs4all.nl>.
 * Copyright (c) 2004-2013 BSD Perimeter
 * Copyright (c) 2013-2016 Electric Sheep Fencing
 * Copyright (c) 2014-2023 Rubicon Communications, LLC (Netgate)
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

require_once("globals.inc");
require_once("config.inc");
require_once("functions.inc");
require_once("shaper.inc");

global $config, $ssh_keys, $sshConfigDir;

if (!isset($config['system']['ssh']['enable'])) {
	return;
}

$keyfiles = array();
foreach ($ssh_keys as $key) {
	$keyfiles[] = "ssh_host_{$key['suffix']}key";
	$keyfiles[] = "ssh_host_{$key['suffix']}key.pub";
}

/*    if any of these files are 0 bytes then they are corrupted.
 *    remove them
 */
foreach ($keyfiles as $f2c) {
	if (!file_exists("{$sshConfigDir}/{$f2c}") || filesize("{$sshConfigDir}/{$f2c}") == 0) {
		/* Make sure we remove both files */
		unlink_if_exists($sshConfigDir . '/' . basename($f2c, ".pub"));
		unlink_if_exists($sshConfigDir . '/' . $f2c);
	}
}

if (!is_dir("/var/empty")) {
	/* make ssh home directory */
	mkdir("/var/empty", 0555);
}

if (!file_exists("/var/log/lastlog")) {
	/* Login related files. */
	@touch("/var/log/lastlog");
}

if (is_array($config['system']['ssh']) && !empty($config['system']['ssh']['port'])) {
	$sshport = $config['system']['ssh']['port'];
} else {
	$sshport = 22;
}

/* Include default configuration for pfSense */
/* Taken from https://stribika.github.io/2015/01/04/secure-secure-shell.html */
$sshconf = "# This file is automatically generated at startup\n";
$sshconf .= "KexAlgorithms curve25519-sha256@libssh.org,diffie-hellman-group-exchange-sha256\n";
/* Run the server on another port if we have one defined */
$sshconf .= "Port $sshport\n";
/* Only allow protocol 2, because we say so */
$sshconf .= "Protocol 2\n";
foreach ($ssh_keys as $key) {
	$sshconf .= "HostKey {$sshConfigDir}/ssh_host_{$key['suffix']}key\n";
}
$sshconf .= "Compression delayed\n";
$sshconf .= "ClientAliveInterval 30\n";
if (is_account_disabled("admin") || is_account_expired("admin")) {
	$permitroot = 'no';
} else {
	$permitroot = 'yes';
}
$sshconf .= "PermitRootLogin {$permitroot}\n";
if ($config['system']['ssh']['sshdkeyonly'] == "both") {
	$sshconf .= "# Login via both Key and Password only\n";
	$sshconf .= "AuthenticationMethods publickey,password\n";
	$sshconf .= "ChallengeResponseAuthentication yes\n";
	$sshconf .= "PasswordAuthentication yes\n";
	$sshconf .= "PubkeyAuthentication yes\n";
	$sshconf .= "UsePAM yes\n";
} else if (isset($config['system']['ssh']['sshdkeyonly'])) {
	$sshconf .= "# Login via Key only\n";
	$sshconf .= "ChallengeResponseAuthentication no\n";
	$sshconf .= "PasswordAuthentication no\n";
	$sshconf .= "PubkeyAuthentication yes\n";
	$sshconf .= "UsePAM no\n";
} else {
	$sshconf .= "# Login via Key or Password\n";
	$sshconf .= "ChallengeResponseAuthentication yes\n";
	$sshconf .= "PasswordAuthentication yes\n";
	$sshconf .= "PubkeyAuthentication yes\n";
}
$sshconf .= "UseDNS no\n";
$sshconf .= "LoginGraceTime 30s\n";
/* Hide FreeBSD version */
$sshconf .= "VersionAddendum none\n";
if (isset($config['system']['ssh']['sshdagentforwarding'])) {
	$sshconf .= "AllowAgentForwarding yes\n";
} else {
	$sshconf .= "AllowAgentForwarding no\n";
}
$sshconf .= "X11Forwarding no\n";
$sshconf .= "Ciphers chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes128-gcm@openssh.com,aes256-ctr,aes192-ctr,aes128-ctr\n";
$sshconf .= "MACs hmac-sha2-512-etm@openssh.com,hmac-sha2-256-etm@openssh.com,umac-128-etm@openssh.com,hmac-sha2-512,hmac-sha2-256,umac-128@openssh.com\n";
$sshconf .= "# override default of no subsystems\n";
$sshconf .= "Subsystem\tsftp\t/usr/libexec/sftp-server\n";

/* Apply package SSHDCond settings if config file exists */
if (file_exists("/etc/sshd_extra")) {
	$fdExtra = fopen("/etc/sshd_extra", 'r');
	$szExtra = fread($fdExtra, 1048576); // Read up to 1MB from extra file
	$sshconf .= $szExtra;
	fclose($fdExtra);
}

/* Write the new sshd config file */
@file_put_contents("{$sshConfigDir}/sshd_config", $sshconf);

/* mop up from a badly implemented ssh keys -> cf backup */
if ($config['ssh']['dsa_key'] <> "") {
	unset($config['ssh']['dsa_key']);
	unset($config['ssh']['ecdsa_key']);
	unset($config['ssh']['ed25519_key']);
	unset($config['ssh']['rsa_key']);
	unset($config['ssh']['rsa1_key']);
	unset($config['ssh']['dsa']);
	unset($config['ssh']['rsa']);
	unset($config['ssh']['rsa1']);
	unset($config['ssh']['ak']);
	write_config("Clearing SSH keys from config.xml");
}

/* are we already running?  if so exit */
if (is_subsystem_dirty('sshdkeys') && is_process_running("ssh-keygen")) {
	unset($keyfiles);
	return;
}

// Check for all needed key files. If any are missing, the keys need to be regenerated.
$generate_keys = array();
foreach ($ssh_keys as $key) {
	if (!file_exists("{$sshConfigDir}/ssh_host_{$key['suffix']}key") ||
	    !file_exists("{$sshConfigDir}/ssh_host_{$key['suffix']}key.pub")) {
		$generate_keys[] = $key;
	}
}

if (!empty($generate_keys)) {
	/* remove previous keys and regen later */
	file_notice("SSH", "{$g['product_label']} has started creating missing SSH keys.  SSH Startup will be delayed.  Please note that reloading the filter rules and changes will be delayed until this operation is completed.", "SSH KeyGen", "");
	mark_subsystem_dirty('sshdkeys');
	echo " Generating Keys:\n";
	foreach ($generate_keys as $key) {
		$_gb = exec("/usr/bin/nice -n20 /usr/bin/ssh-keygen -t {$key['type']} -b 4096 -N '' -f {$sshConfigDir}/ssh_host_{$key['suffix']}key");
	}
	clear_subsystem_dirty('sshdkeys');
	file_notice("SSH", "{$g['product_label']} has completed creating your SSH keys.  SSH is now started.", "SSH Startup", "");
}

/* kill existing sshd process, server only, not the children */
$sshd_pid = exec("ps ax | egrep '/usr/sbin/[s]shd' | awk '{print $1}'");
if ($sshd_pid <> "") {
	echo "stopping ssh process $sshd_pid \n";
	@posix_kill($sshd_pid, SIGTERM);
}
/* Launch new server process */
$status = mwexec("/usr/sbin/sshd");
if ($status <> 0) {
	file_notice("sshd_startup", "SSHD failed to start.", "SSHD Daemon", "");
	echo "error!\n";
} else {
	echo "done.\n";
}

unset($keyfiles);
?>
